{
  "sidebar.actions": "Actions",
  "sidebar.tests": "Tests",
  "sidebar.operators": "Operators",
  "debug.tab.script": "Script",
  "debug.tab.capabilities": "Capabilities",
  "debug.tab.advanced": "Advanced",
  "debug.script.input": "Input:",
  "debug.script.parse": "Parse Sieve Script",
  "debug.script.result": "Result:",
  "debug.script.update": "Update Sieve Script",
  "debug.advanced.compact": "Compact",
  "debug.capabilities.script": "Load from Script",
  "debug.capabilities.none": "Select None",
  "debug.capabilities.all": "Select All",
  "debug.capabilities.apply": "Apply",
  "stringlist.add": "Add",
  "numeric.nounit": "No Unit",
  "numeric.kilobytes": "Kilobytes",
  "numeric.megabytes": "Megabytes",
  "numeric.gigabytes": "Gigabytes",
  "return.tab.help": "Hilfe",
  "return.help": "",
  "stop.tab.help": "Hilfe",
  "stop.help": "",
  "discard.tab.help": "Hilfe",
  "discard.help": "",
  "keep.tab.help": "Hilfe",
  "keep.help": "",
  "fileinto.tab.home": "Fileinto",
  "fileinto.tab.help": "Hilfe",
  "fileinto.folder.label": "Save the incoming message into folder:",
  "fileinto.folder.placeholder": "Enter folder",
  "fileinto.folder.invalid": "Invalid folder name",
  "fileinto.help.text": "The mailbox name is typically a hierarchical name used to determine a folder on the server. So it is equivalent with the folder structure you can see in your mail client.\n\nThere is no precise definition how the hierarchical name is formed. It depends on your mail server implementation. Only the case-insensitive mailbox name INBOX is a special name reserved to mean \"the primary mailbox for this user on this server\".\n\nBut you should avoid using non-graphical characters, the list-wildcard characters (\"%\" and \"*\"), characters which are reserved by the server for the level of hierarchy (typically \"/\" or \".\") as well as \"#\" as \"&\" because they can have special meanings.",
  "fileinto.summary": "Save message into:",
  "exists.tab.home": "Exists",
  "exists.tab.help": "Hilfe",
  "exists.header.label": "All of the following header exist:",
  "exists.help.text": "",
  "exists.summary1": "Header(s)",
  "exists.summary2": "exist",
  "header.tab.home": "Header",
  "header.tab.advanced": "Erweitert",
  "header.tab.help": "Hilfe",
  "header.header": "Any of the following header ... ",
  "header.keywords": "... any of the keyword(s):",
  "header.help": "Compares headers against constant strings.\n\nYou typically use this test with headers containing subject line or a spam score.\n\nDo not use this test, if the header should be matched against a mail addresses. The result will be unreliable, as this test is not aware of display names. Use the address test instead.",
  "header.summary": "header",
  "addheader.tab.home": "Add Header",
  "addheader.tab.help": "Hilfe",
  "addheader.name": "Create a new header ...",
  "addheader.name.invalid": "Invalid header name, has to be a non empty 7bit ASCII string",
  "addheader.value": "... with a value of ...",
  "addheader.value.invalid": "Invalid header value, has to be non empty",
  "addheader.position": "... and add as ...",
  "addheader.first": "... first header",
  "addheader.last": "... last header",
  "addheader.help": "Adds a new header to the message. The existing message header are untouched. By default, the header field is inserted at the beginning of the existing message header.",
  "addheader.hint": "The header name is by definition a case insensitive 7bit US-ASCII string. Leading and tailing whitespace are ignored. Headers with invalid names are silently ignored.",
  "addheader.summary1": "Add header",
  "addheader.summary2": "with value",
  "deleteheader.tab.home": "Delete Header",
  "deleteheader.tab.advanced": "Advanced",
  "deleteheader.tab.help": "Help",
  "deleteheader.position": "Delete ...",
  "deleteheader.all": "... all ...",
  "deleteheader.first": "... the first",
  "deleteheader.last": "... the last",
  "deleteheader.name": "... header named ...",
  "deleteheader.name.invalid": "Invalid header name, has to be a non empty 7bit ASCII string",
  "deleteheader.value": "... with ...",
  "deleteheader.any": "... any value",
  "deleteheader.some": "... one of the following values ...",
  "deleteheader.some.matchtype": "... which ...",
  "deleteheader.some.keywords": "... any of the keyword(s):",
  "deleteheader.help": "By default, the deleteheader action deletes all occurrences of the named header field. The deleteheader action does not affect Sieve's implicit keep",
  "deleteheader.hint": "The header name is by definition a case insensitive 7bit US-ASCII string. Leading and tailing whitespace are ignored. Headers with invalid names are silently ignored.",
  "deleteheader.summary1": "Remove a header",
  "deleteheader.summary2": "with a value",
  "mailboxexists.tab.home": "Mailbox exists",
  "mailboxexists.tab.help": "Hilfe",
  "mailboxexists.folders": "All of the following mailboxes (folders) exist:",
  "mailboxexists.help": "Verifies existence of mailboxes\n\nTests if all mailbox folders listed exist in the mailstore and if delivery is possible. Delivery is possible means the user has access right and the is allowed to read and write the folder.\n\n Note that a successful \"mailboxexists\" test doesn't necessarily mean that a \"fileinto\" action on this mailbox would succeed. For example, the \"fileinto\" action might put user over quota.",
  "mailboxexists.summary1": "Mailbox(es)",
  "mailboxexists.summary2": "exists",
  "metadataexists.tab.home": "Meta Data exists",
  "metadataexists.tab.help": "Hilfe",
  "metadataexists.folder": "The mailbox (folder) ...",
  "metadataexists.annotations": "... has all of the following annotations:",
  "metadataexists.help": "Checks a mailbox for annotations\n\nThe test return true if all of the annotations exist (i.e., have non-NIL values) for the specified mailbox.",
  "metadataexists.summary1": "Mailbox",
  "metadataexists.summary2": "has all annotations",
  "metadata.tab.home": "Meta Data",
  "metadata.tab.advanced": "Erweitert",
  "metadata.tab.help": "Hilfe",
  "metadata.annotation": "The annotation ...",
  "metadata.folder": "... in mailbox/folder ...",
  "metadata.matchtype": "... has a value which ...",
  "metadata.keys": "... any of the following keys:",
  "metadata.help": "",
  "metadata.summary1": "Annotation",
  "metadata.summary2": "in folder",
  "metadata.summary3": "has a value which",
  "metadata.summary4": "any of",
  "servermetadataexists.tab.home": "Server Meta Data exists",
  "servermetadataexists.tab.help": "Hilfe",
  "servermetadataexists.annotations": "The server has all of the following annotations:",
  "servermetadataexists.help": "Checks a mailbox for annotations\n\nThe test is true if all of the server annotations listed in the annotations exist (i.e., have non-NIL values).",
  "servermetadataexists.summary": "The server supports annotations ",
  "servermetadata.tab.home": "Server Meta Data",
  "servermetadata.tab.advanced": "Erweitert",
  "servermetadata.tab.help": "Hilfe",
  "servermetadata.annotation": "The server annotation ... ",
  "servermetadata.matchtype": "... has a value which ...",
  "servermetadata.keys": "... any of the following keys:",
  "servermetadata.help": "",
  "servermetadata.summary1": "Server annotation",
  "servermetadata.summary2": "has a value which",
  "servermetadata.summary3": "any of",
  "reject.tab.home": "Reject",
  "reject.tab.help": "Hilfe",
  "reject.deprecated": "Reject is unsafe and was replaced by the ereject.",
  "reject.reject": "Reject incoming messages and reply the following reason:",
  "reject.help": "Reject is replaced by the ereject and should not be used anymore, because it is unsafe. The ereject action is similar to reject, but will always favor protocol-level message rejection.",
  "reject.summary": "Reject incoming messages and reply the following reason:",
  "set.tab.home": "Set",
  "set.tab.advanced": "Advanced",
  "set.tab.help": "Help",
  "set.value": "Store the value ...",
  "set.variable": "... into variable",
  "set.variable.invalid": "Invalid variable name",
  "set.modifier": "Modifiers are used to change a variables' value. They are processed in the following order",
  "set.case": "Modify variable's case",
  "set.case.text": "Only plain Latin (A-Z and a-z) are changed, no umlauts or similar characters.",
  "set.case.upper": "upper case",
  "set.case.lower": "lower case",
  "set.first": "Modify variable's first character",
  "set.first.text": "Only the first character's case is changed, the rest of the string is unchanged.",
  "set.first.upper": "upper case",
  "set.first.lower": "lower case",
  "set.help": "Stores the specified value in the variable identified by name.\n\n The name has to be a constant string and conform to the syntax of variable-name. Variable names are case insensitive.\n\n Modifiers are applied before it is stored in the variable. If more than one modifier is specified, they are applied according to this precedence list:\n\n • Variable's case\n • Variable's first character\n • Escape Wildcards\n • Count characters\n",
  "set.summary1": "Set variable",
  "set.summary2": "to value",
  "ereject.tab.home": "Reject",
  "ereject.tab.help": "Hilfe",
  "ereject.reject": "Reject incoming messages and reply the following reason:",
  "ereject.help": "",
  "string.tab.home": "String",
  "string.tab.advanced": "Erweitert",
  "string.tab.help": "Hilfe",
  "string.variables": "Any of the following strings ...",
  "string.keywords": "... any of the keyword(s):",
  "string.help": "",
  "string.summary": "string",
  "notify.tab.home": "Notify",
  "notify.tab.advanced": "Erweitert",
  "notify.tab.help": "Hilfe",
  "notify.method": "Use the Method...",
  "notify.method.tel": "Senden eine SMS an eine Telefonnummer",
  "notify.method.tel.text": "z.B. tel:+14085551212",
  "notify.method.xmpp": "Sende ein xmpp Nachricht",
  "notify.method.xmpp.text": "z.B. xmpp:me@example.com?message;subject=SIEVE;body=You%20got%20mail",
  "notify.method.mail": "Sende eine E-Mail",
  "notify.method.mail.text": "z.B. mailto:me@example.com",
  "notify.message.default": "... to send the server's default message",
  "notify.message.default.text": "A default implementation-specific message is used. It contains at least the value of the \"From\" header field and the value of the \"Subject\".",
  "notify.message.custom": "... to send a custom message",
  "notify.message.custom.text": "The message data to be included in the notification. Implementations may shorten the message for technical or aesthetic reasons.",
  "notify.from": "Override the default sender",
  "notify.from.text": "The server's default is normally the current user. You can override this, but in oder minimize/prevent forgery of the author value, the server implementations impose restrictions on what values can be specified.",
  "notify.importance": "Override the default importance",
  "notify.importance.text": "Only few protocols support an importance or priority at all. Refer to the method's documentation for more details on how the importance is mapped.",
  "notify.importance.high": "Hoch",
  "notify.importance.normal": "Normal",
  "notify.importance.low": "Niedrig",
  "notify.summary": "Send notification",
  "notify.options": "Set additional options",
  "notify.options.text": "Additional options passed to the mechanism as key and value pairs. Refer to the specific mechanisms for more details.",
  "notify.help": "Specifies that a notification should be sent to a user. The format of the notification is implementation-defined and is affected by the notification method used.\n\n The notification method is identified by a URI. For example, the notification method can be a tel URI [TEL-URI] with a phone number to send SMS messages to, or an XMPP [XMPP] URI containing an XMPP identifiers [XMPP-URI]. The supported notification methods are site-specific, but support for the [MailTo] method is guaranteed.\n\nSieve scripts should check the supported methods using the valid_notify_method test to be sure that they only use supported ones.",
  "notify.help.alert": "An implementation may enforce semantic restrictions on URIs. For example, to restrict phone numbers in a tel URI to a particular geographical region. This will cause a parser error.",
  "notifymethodcapability.summary": "Check Notify Method Capability",
  "validnotifymethod.tab.home": "Valid notify method",
  "validnotifymethod.tab.help": "Hilfe",
  "validnotifymethod.notifyuris": "All notify methods are supported...",
  "validnotifymethod.help": "",
  "validnotifymethod.summary": "Notify methods are supported",
  "redirect.tab.home": "Redirect",
  "redirect.tab.help": "Hilfe",
  "redirect.address.label": "E-Mail weiterleiten an:",
  "redirect.address.placeholder": "Hier die E-Mail Adresse eingeben",
  "redirect.address.invalid": "Invalid redirect address",
  "redirect.help": "Redirect forwards the message to the given address. It makes no changes to the message body or existing headers, but it may add new headers.\n\n The envelope sender address on the outgoing message is chosen by the sieve implementation.\n\nImplementations may ignore a redirect action silently due to policy reasons.",
  "redirect.summary": "Redirect message to",
  "stop.summary": "End Script (Stop processing)",
  "discard.summary": "Discard message silently",
  "keep.summary": "Keep a copy in the main inbox",
  "size.tab.home": "Size",
  "size.tab.help": "Help",
  "size.description": "Check if message size is ... ",
  "size.larger": "larger",
  "size.smaller": "smaller",
  "size.compare": "... than ...",
  "size.help": "Compares the message size.\n\nTest the message size is greater or smaller than the given size. The size is measured in bytes, character encoding are ignored.\n\n",
  "size.help.warning": "There is only a larger or smaller, no equals. A message with exactly 4000 bytes is neither larger nor smaller than 4000 bytes.",
  "size.summary.message": "message is",
  "size.summary.larger": "larger",
  "size.summary.smaller": "smaller",
  "size.summary.than": "than",
  "envelope.tab.home": "Envelope",
  "envelope.tab.advanced": "Advanced",
  "envelope.tab.help": "Help",
  "envelope.envelopes": "Any of the following envelope fields ...",
  "envelope.keywords": "... any of the keyword(s):",
  "envelope.help": "Compares fields against the envelope\n\nThe envelop is equivalent to the mail delivery protocol. So it does not test against a real header. Instead uses trace information from the mail delivery protocol for specific values.\n\nA \"to\" tests the SMTP sender field \"RCPT TO\" a \"from\" the recipient \"MAIL FROM\".\n\nIt is the most reliant way to test from which address a message was send to or received.\n\nCompares headers against constant strings.\n\nYou typically use this test with headers containing subject line or a spam score.\n\nDo not use this test, if the header should be matched against a mail addresses. The result will be unreliable, as this test is not aware of display names. Use the address test instead.",
  "envelope.summary": "envelope",
  "address.tab.home": "Address",
  "address.tab.advanced": "Erweitert",
  "address.tab.help": "Hilfe",
  "address.headers": "Einer der folgenden Header ...",
  "address.keywords": "... eines der folgenden Schlüsselwörter",
  "address.help": "Compares headers against E-Mail addresses.\n\nYou typically use test with headers like \"to\", \"from\", \"cc\" etc.\n\nAs this test is aware of e-mail addresses containing display names. A header containing '\"roadrunner\" <roadrunner@acme.example.com>' is considered to be equivalent to \"'roadrunner@acme.example.com\"\n\nIf the header should be matched against a string use the header test.",
  "address.summary": "address",
  "allofanyof.tab.home": "AllOf/AnyOf",
  "allofanyof.tab.help": "Hilfe",
  "allofanyof.label": "Test ist erfüllt wenn...",
  "allofanyof.allof": "... alle Bedingungen erfüllt sind.",
  "allofanyof.anyof": "... mindestens eine Bedingungen erfüllt ist.",
  "allofanyof.help": "",
  "boolean.tab.home": "Boolean",
  "boolean.tab.help": "Hilfe",
  "boolean.label": "Make this test always",
  "boolean.true": "succeed (true)",
  "boolean.false": "fail (false)",
  "boolean.help": "Der Boolesche Test ist von begrenztem praktischem Nutzen. Die Bedingung ist immer erfüllt wenn er auf wahr (true) bzw. nie erfüllt wenn er auf falsch (false) gesetzt ist.",
  "boolean.summary.true": "is true",
  "boolean.summary.false": "is false",
  "condition.if": "if",
  "condition.else": "else",
  "condition.elseif": "elseif",
  "operator.allof.summary": "All of the following:",
  "operator.anyof.summary": "Any of the following:",
  "duplicate.tab.home": "Duplicate",
  "duplicate.tab.advanced": "Advanced",
  "duplicate.tab.help": "Help",
  "duplicate.summary": "is a duplicate",
  "duplicate.unique.label": "The unique id is...",
  "duplicate.tracking.title": "Tracking Handles",
  "duplicate.tracking.text": "Duplicate tracking considers only messages which are tagged with the same handle. The rational is to have multiple tracking policies. In case no handle it provided the server will use a default one. A custom handle can be any unique strings.",
  "duplicate.tracking.default": "Use default handle",
  "duplicate.tracking.custom": "Custom Handle",
  "duplicate.tracking.custom.invalid": "Invalid custom handle",
  "duplicate.expiration.title": "Expiration",
  "duplicate.expiration.text": "The server uses a duplicate message list to track duplicates. To keep this list small and fast, the list entries expire. After a list entry is expired it is no more considered as a Duplicate",
  "duplicate.expiration.default": "Use server's default policy (usually 7 days)",
  "duplicate.expiration.custom.pre": "Expire after",
  "duplicate.expiration.custom.post": "seconds",
  "duplicate.expiration.custom.invalid": "Invalid expiration time",
  "duplicate.time.text": "Expiration time uses either the point in time when the entry in the duplicate message list was created or the point in time when the duplicate message entry was last accessed.",
  "duplicate.time.created": "The moment the entry was created",
  "duplicate.time.accessed": "The timestamp of the most recent access",
  "duplicate.help": "The main application for this test is handling duplicate deliveries commonly caused by mailing list subscriptions or redirected mail addresses.\n\n The detection is normally performed by matching the message ID to an internal list of message IDs from previously delivered messages.\n\n For more complex applications, the \"duplicate\" test can also use the content of a specific header field or other parts of the message.\n\nDuplicate deliveries are a common side effect of being subscribed to a mailing list. For example, if a member of the list decides to reply to both the user and the mailing list itself, the user will often get one copy of the message directly and another through the mailing list.",
  "return.summary": "End current script and return to the parent script",
  "global.tab.home": "Global",
  "global.tab.help": "Help",
  "global.title": "Export variables into the global namespace:",
  "global.help": "",
  "global.summary": "Define global variable(s):",
  "include.tab.home": "Include",
  "include.tab.advanced": "Advanced",
  "include.tab.help": "Help",
  "include.name": "Include script name:",
  "include.name.placeholder": "Script name",
  "include.name.invalid": "Invalid script name",
  "include.once.label": "Include at most once",
  "include.once.text": "Subsequent include calls to the same script are silently discarded",
  "include.optional.label": "Script is optional",
  "include.optional.text": "By default a include throws an error if the script is not found.\nIn case script flagged as optional and is missing, it will be silently skipped.",
  "include.storage": "Storage Location",
  "include.personal.label": "Personal (default)",
  "include.personal.text": "Personal scripts are located in your personal and private Sieve repository.",
  "include.global.label": "Global",
  "include.global.text": "Global scripts are stored in a site-wide Sieve repository.\nIt is accessible to all users any typically provided and maintained by your administrator.",
  "include.help": "",
  "include.summary1": "Include",
  "include.summary.personal": "global",
  "include.summary.global": "personal",
  "include.summary2": "script",
  "date.tab.home": "Date",
  "date.tab.advanced": "Advanced",
  "date.tab.help": "Help",
  "date.header": "Has a Header ... ",
  "date.datepart": "... where the ...",
  "date.keywords": "... any of the keyword(s):",
  "date.timezone": "Timezone",
  "date.comparator": "Comparator",
  "date.help": "The date/time information is extracted from the header, shifted to the specified time zone, and the value of the given date-part is determined.\n\nThe test returns true if the resulting string matches any of the strings specified in the key-list.\n\nThe date test returns false if the specified header field does not exist, the field exists but does not contain a syntactically valid date-time specification, the date-time isn't valid according to the rules of the calendar system (e.g., January 32nd, February 29 in a non-leap year), or the resulting string fails to match any key-list value\n\n Unlike the header and address tests, the date test can only be applied to a single header field at a time. If multiple header fields with the same name are present, only the first field that is found is used.",
  "date.summary.inheader": "in header",
  "date.summary.anyof": "any of",
  "currentdate.tab.home": "Current Date",
  "currentdate.tab.advanced": "Advanced",
  "currentdate.tab.help": "Help",
  "currentdate.datepart": "The current...",
  "currentdate.keyword": "... any of the keyword(s):",
  "currentdate.timezone": "Timezone",
  "currentdate.comparator": "Comparator",
  "currentdate.help": "The currentdate test is similar to the date test, except that it operates on the current date/time rather than a value extracted from the message header.\n\nThe test returns true if the current date matches any of the strings specified in the key-list. It returns false if the resulting string fails to match any key-list value.",
  "currentdate.summary.current": "The current",
  "currentdate.summary.anyof": "any of",
  "datepart.year": "year",
  "datepart.year.text": "\"0000\" ... \"9999\"",
  "datepart.month": "month",
  "datepart.month.text": "\"01\" ... \"12\"",
  "datepart.day": "day",
  "datepart.day.text": "\"01\" ... \"31\"",
  "datepart.date": "date",
  "datepart.date.text": "\"yyyy-mm-dd\"",
  "datepart.hour": "hour",
  "datepart.hour.text": "\"00\" ... \"23\"",
  "datepart.minute": "minute",
  "datepart.minute.text": "\"00\" ... \"59\"",
  "datepart.second": "second",
  "datepart.second.text": "\"00\" ... \"60\"",
  "datepart.time": "time",
  "datepart.time.text": "\"hh:mm:ss\"",
  "datepart.iso8601": "iso8601",
  "datepart.iso8601.text": "Restricted ISO 8601 Format (RFC3339)",
  "datepart.std11": "std11",
  "datepart.std11.text": "Internet Message Format (RFC2822)",
  "datepart.zone": "zone",
  "datepart.zone.text": "Time zone (\"+hhmm\" or \"-hhmm\")",
  "datepart.weekday": "weekday",
  "datepart.weekday.text": "\"0\" (Sunday) ... \"6\" (Saturday)",
  "datepart.julian": "julian",
  "datepart.julian.text": "days since 1858-11-17 0:00 UTC",
  "zone.original": "Original zone",
  "zone.original.text": "Use the time zone offset from the date-time value.",
  "zone.custom": "Adjust Timezone",
  "zone.custom.text": "Shift the zone offset from the date-time value.\n\nOffsets are written in the format ±[hh][mm]. They can range from -1200 to +1400 and represent whole numbers of hours. Few zones are offset by 30 or 45 minutes like e.g. −0330 or +0545",
  "convert.tab.home": "Convert",
  "convert.tab.help": "Help",
  "convert.from": "Convert the media type",
  "convert.to": "... into ...",
  "convert.transcode": "... and apply the following transcodings",
  "convert.transcode.text": "Transcodings are defined in RFC5259 and used to change properties during conversion.  Examples are rescale an images or change the encoding encoding of a text.",
  "convert.help": "Converts the whole message or their part into the a new media type. It is typically used to convert text documents and images as described in RFC5259.\n\nTheoretically it would be possible to convert everything into anything (e.g. an audio file into text). But in reality your server will support only a very limited subset of conversions. Keep in mind conversion may require lots of resources and processing time e.g. when rescaling images or creating pdfs.\n\nIn case the conversion fails the message remains unchanged. If this method is used inside a test. The test will performing the conversion and evaluate if the conversion succeeded or failed.",
  "convert.summary.from": "Convert",
  "convert.summary.to": "to",
  "body.tab.home": "Body",
  "body.tab.advanced": "Advanced",
  "body.tab.help": "Help",
  "body.matchtypes": "The email's message body...",
  "body.keylist": "... any of the keyword(s):",
  "body.comparator": "Comparator",
  "body.transform": "Match against...",
  "body.help": "The body test matches content in the body of an email message, that is, anything following the first empty line after the header. (The empty line itself, if present, is not considered to be part of the body.",
  "body.summary": "message body",
  "addflag.tab.home": "Add Flag",
  "addflag.tab.help": "Help",
  "addflag.flags.title": "Add the following IMAP Flags ...",
  "addflag.flags.text": "It doesn't replace any previously set flags. This means that multiple occurrences of addflag are treated additively.",
  "addflag.help": "Add flags to a message. It doesn't replace any previously set flags. This means that multiple occurrences of addflag are treated additively.\n\nMessage labels are called flags in the IMAP specification and are divided into two types: system flags and user-defined flags.\n\nSystem flags are defined in the IMAP Specification. They start with a leading backslash (\\). The current the following six system flags \\Seen, \\Answered, \\Flagged, \\Deleted, \\Draft, \\Recent are defined.\n\nUser-defined flags are also known as IMAP keywords and, as the name implies, are defined by IMAP users. There is a de facto standard that keywords which are in common use have names that begin with a dollar sign ($).\n\nExamples of common keywords are: $Label1, $Label2, $Label3, $Label4, $Label5. These keywords are typically hardwired to Important, Work, Personal, To Do and Later.\n\nIf you define your own personal keyword, its name should not begin with dollar sign ($) or backslash (\\) because otherwise it might collide with a flag that is used by current or future IMAP clients and servers",
  "addflag.summary": "Add IMAP flag(s)",
  "spamtest.tab.home": "Spamtest",
  "spamtest.tab.advanced": "Advanced",
  "spamtest.tab.help": "Help",
  "spamtest.spamscore": "The spam score...",
  "spamtest.help": "",
  "spamtest.absolute.label": "... absolute value ...",
  "spamtest.absolute.text": "By default sieve uses a spam score ranging from zero to ten describing the likelihood to be spam. Where zero means untested, one clear of spam and ten definitive spam.",
  "spamtest.absolute.nottested": "Message was not tested for spam",
  "spamtest.absolute.nospam": "Message is clear of spam",
  "spamtest.absolute.likelyspan": "Message's spam likelihood",
  "spamtest.absolute.spam": "Message definitely contains spam",
  "spamtest.percent.label": "... percentual value ...",
  "spamtest.percent.text": "The spam score can also be a likelihood ranging from zero to 100. Where zero means no spam or untested and 100 definitive spam",
  "spamtest.percent.nospam": "Message was not tested for spam or is clear of spam",
  "spamtest.percent.likelyspan": "Message's spam likelihood in percent",
  "spamtest.percent.spam": "Message definitely contains spam",
  "spamtest.summary": "Spam score",
  "hasflag.tab.home": "Has Flag",
  "hasflag.tab.advanced": "Advanced",
  "hasflag.tab.help": "Help",
  "hasflag.flags.title": "An imap flag... ",
  "hasflag.flags.keyword": "... any of the keyword(s):",
  "hasflag.help": "Message labels are called flags in the IMAP specification and are divided into two types: system flags and user-defined flags.\n\n  System flags are defined in the IMAP Specification. They start with a leading backslash (\\). The current the following six system flags \\Seen, \\Answered, \\Flagged, \\Deleted, \\Draft, \\Recent are defined.\n\nUser-defined flags are also known as IMAP keywords and, as the name implies, are defined by IMAP users. There is a de facto standard that keywords which are in common use have names that begin with a dollar sign ($).\n\n Examples of common keywords are: $Label1, $Label2, $Label3, Label4, $Label5. These keywords are typically hardwired to Important, Work, Personal, To Do and Later.\n\n If you define your own personal keyword, its name should not begin with dollar sign ($) or backslash (\\) because otherwise it might collide with a flag that is used by current or future IMAP clients and servers.",
  "hasflag.summary": "An IMAP flags(s)",
  "removeflag.tab.home": "Remove Flag",
  "removeflag.tab.help": "Help",
  "removeflag.flags.title": "Remove the following IMAP Flags ...",
  "removeflag.flags.text": "Removeflag clears flags previously set by setflag or addflag",
  "removeflag.help": "Removeflag clears flags previously set by \"setflag\" or \"addflag\". Calling removeflag with a flag that wasn't set before is not an error and is ignored. \n\nAdd flags to a message. It doesn't replace any previously set flags. This means that multiple occurrences of addflag are treated additively.\n\nMessage labels are called flags in the IMAP specification and are divided into two types: system flags and user-defined flags.\n\nSystem flags are defined in the IMAP Specification. They start with a leading backslash (\\). The current the following six system flags \\Seen , \\Answered, \\Flagged, \\Deleted, \\Draft, \\Recent are defined.\n\nUser-defined flags are also known as IMAP keywords and, as the name implies, are defined by IMAP users. There is a de facto standard that keywords which are in common use have names that begin with a dollar sign ($).\n\nExamples of common keywords are: $Label1, $Label2, $Label3, $Label4, $Label5. These keywords are typically hardwired to Important, Work, Personal, To Do and Later.\n\nIf you define your own personal keyword, its name should not begin with dollar sign ($) or backslash (\\) because otherwise it might collide with a flag that is used by current or future IMAP clients and servers",
  "removeflag.summary": "Remove IMAP flag(s)",
  "setflags.tab.home": "Set Flag",
  "setflags.tab.help": "Help",
  "setflags.flags.title": "Set the following IMAP Flags ...",
  "setflags.flags.text": "It replaces any previously set flags.",
  "setflag.help": "Setflag is used for setting system flags, it replaces any previously set flags.\n\nMessage labels are called flags in the IMAP specification and are divided into two types: system flags and user-defined flags.\n\nSystem flags are defined in the IMAP Specification. They start with a leading backslash (\\). The current the following six system flags \\Seen , \\Answered, \\Flagged, \\Deleted, \\Draft, \\Recent are defined.\n\nUser-defined flags are also known as IMAP keywords and, as the name implies, are defined by IMAP users. There is a de facto standard that keywords which are in common use have names that begin with a dollar sign ($).\n\n Examples of common keywords are: $Label1, $Label2, $Label3, $Label4, $Label5. These keywords are typically hardwired to Important, Work, Personal, To Do and Later.\n\nIf you define your own personal keyword, its name should not begin with dollar sign ($) or backslash (\\) because otherwise it might collide with a flag that is used by current or future IMAP clients and servers",
  "setflag.summary": "Set IMAP flag(s)",
  "flags.label": "Add imap flag",
  "flags.text": "Adds flags to a message. It doesn't replace any previously set flags.",
  "copy.label": "Keep a copy",
  "copy.text": "By default the action cancels the implicit keep statement. So that it won't be stored in the inbox after processing. When activating a copy of the original message is kept in the inbox.",
  "create.label": "Create folder, when non existent",
  "unique.default.title": "... extracted from the header named message-id.",
  "unique.default.text": "The message-id is assumed but not guaranteed to be globally unique.",
  "unique.header.title": "... extracted from the header named:",
  "unique.header.text": "Often mailinglist or ticket system use special headers to track duplicates.",
  "unique.id.title": "... is provided:",
  "unique.id.text": "Using a static string does not sound too usefull. But in combination with sieve variables, the string will get virtually dynamic. And you are able to create almost any unique id pattern to match against.",
  "bodyTransform.contentType": "... the MIME parts that have the specified content types:",
  "bodyTransform.text": "... the decoded message body. (Default)",
  "bodyTransform.raw": "... the entire undecoded message body",
  "matchtype.is.title": "... is ...",
  "matchtype.is.text": "Only \"frobnitzm\" is \"frobnitzm\"",
  "matchtype.contains.title": "... contains ...",
  "matchtype.contains.text": "\"frobnitzm\" contains \"frob\" and \"nit\", but not \"fbm\"",
  "matchtype.matches.title": "... matches ...",
  "matchtype.matches.text": "\"*\" matches zero or more characters, and \"?\" matches a single character\n\"frobnitzm\" matches \"frob*zm\" or \"frobnit?m\" but not frob?m",
  "matchtype.value.title": "... is",
  "matchtype.value.title2": "...",
  "matchtype.value.greater": "greater than",
  "matchtype.value.greaterEqual": "greater than or equal",
  "matchtype.value.less": "less than",
  "matchtype.value.lessEqual": "less than or equal",
  "matchtype.value.equal": "equal to",
  "matchtype.value.notEqual": "not equal to",
  "matchtype.value.text": "Compares the relation between strings. The test is considered true if any pair is true",
  "matchtype.regex.title": "... regex matches ...",
  "matchtype.regex.text": "Matches and compares using on a regular expression as defined in IEEE.1003-2.1992",
  "matchtype.count.title": "... has",
  "matchtype.count.title2": "items ...",
  "matchtype.count.greater": "greater than",
  "matchtype.count.greaterEqual": "greater than or equal",
  "matchtype.count.less": "less than",
  "matchtype.count.lessEqual": "less than or equal",
  "matchtype.count.equal": "equal to",
  "matchtype.count.notEqual": "not equal to",
  "matchtype.count.text": "Counts the number of entities and compares them to the given value",
  "modifier.length.title": "Count character",
  "modifier.length.text": "Variables are expanded before determining the number of characters.",
  "modifier.quotewildcard.title": "Escape Wildcards",
  "modifier.quotewildcard.text": "Ensures that the expanded text will only match a literal occurrence if used as a parameter to :matches. Every character with special meaning (\"*\", \"?\", and \"\\\") is prefixed with \"\\\" in the expansion.",
  "modifier.encodeurl.title": "Url Encode",
  "modifier.encodeurl.text": " Url encodes the variable. This means it performs percent-encoding of any octet in the string that doesn't belong to the \"unreserved\" set (see [URI]).",
  "addresspart.all.title": "... an email address with ...",
  "addresspart.all.text": "An email address consists of a domain an a local part split by the \"@\" sign.\nThe local part is case sensitive while the domain part is not.",
  "addresspart.domain.title": "... a domain part with ...",
  "addresspart.domain.text": "Everything after the @ sign. The domain part is not case sensitive.\ne.g.: \"me@example.com\" is stripped to \"example.com\"",
  "addresspart.local.title": "... a local part with ...",
  "addresspart.local.text": "Everything before the @ sign. The local part is case sensitive.\ne.g.: \"me@example.com\" is stripped to \"me\"",
  "addresspart.user.title": "... a user sub-part with ...",
  "addresspart.user.text": "Everything before the + sign or between the -- sequence and the @sign.\nThe localpart part is case sensitive.\ne.g.: \"user+detail@example.com\" or \"detail--user@example.com\" is stripped to \"user\"",
  "addresspart.detail.title": "... a detail sub-part with ...",
  "addresspart.detail.text": "Everything between the + sign and the @ sign, or before a -- sequence.\nThe localpart part is case sensitive.\ne.g.: \"user+detail@example.com\" or \"detail--user@example.com\" is stripped to \"detail\"",
  "comparator.asciicasemap.title": "Case insensitive (default)",
  "comparator.asciicasemap.text": "Treats uppercase and lowercase ASCII characters as the same.\nAll non ASCII characters are compared byte by byte.",
  "comparator.asciinumeric.title": "Numeric",
  "comparator.asciinumeric.text": "Converts the string to an integer and does a numeric compare.",
  "comparator.octet.title": "Case sensitive",
  "comparator.octet.text": "Compares the string byte by byte.",
  "interval.days.label.pre": "Reply at most every",
  "interval.days.label.post": "days",
  "interval.default.label": "Use Server's default policy",
  "interval.seconds.label.pre": "Reply at most every",
  "interval.seconds.label.post": "seconds",
  "virustest.tab.home": "Virustest",
  "virustest.tab.advanced": "Advanced",
  "virustest.tab.help": "Help",
  "virustest.title": "The virus scan result...",
  "virustest.nottested": "Message was not tested for viruses",
  "virustest.notinfected": "Message was tested and contains no known viruses",
  "virustest.sanitized": "Message contained a known virus that was replaced with harmless content",
  "virustest.cured": "Message contained a known virus that was \"cured\" such that it is now harmless",
  "virustest.likelyinfected": "Message possibly contains a known virus",
  "virustest.infected": "Message was tested and definitely contains a known virus",
  "virustest.help": "The \"virustest\" test evaluates to true if the normalized result string matches the value.\n\nThe normalized result string starts with a numeric value in the range \"0\" (zero) through \"5\", with meanings summarized below:",
  "virustest.summary": "Virus check",
  "vacation.tab.home": "Vacation",
  "vacation.tab.envelope": "Envelope",
  "vacation.tab.advanced": "Advanced",
  "vacation.tab.help": "Help",
  "vacation.envelope.subject": "Subject:",
  "vacation.envelope.subject.default": "Server's default Subject",
  "vacation.envelope.from": "From:",
  "vacation.envelope.from.default": "Address of the sieve script owner",
  "vacation.envelope.addresses": "Addresses:",
  "vacation.envelope.text": "Enter your vacation message",
  "vacation.subject": "Subject",
  "vacation.subject.text": "The subject is used for any vacation response",
  "vacation.subject.default": "Server's default Subject",
  "vacation.subject.custom": "Custom Subject",
  "vacation.from": "From address",
  "vacation.from.text": "Used to specify an alternate From address.",
  "vacation.from.default": "Address of the sieve script owner",
  "vacation.from.custom": "Custom From Address",
  "vacation.addresses": "Additional recipients addresses",
  "vacation.addresses.text": "By default a response message is only send, if it was addressed to the recipient user or sieve script owner.\nYou can supply additional mail addresses. For Example if mails are forwarded or you have multiple aliases for a single mail address",
  "vacation.contenttype": "Message Content Type",
  "vacation.contenttype.text": "Instead of plaintext, the message can be a specified as a MIME Message",
  "vacation.contenttype.default": "Is plaintext Message (Default)",
  "vacation.contenttype.mime": "Is MIME Message",
  "vacation.tracking": "Response Tracking",
  "vacation.tracking.text": "A vacation message is sent at most every some days to the same sender",
  "vacation.response": "Response Handles",
  "vacation.response.text": "The response tracking considers all vacation statements that use the same handle as the same response\nThe default handle considers subject, from, mime as well as the message. A custom handle can be any unique strings",
  "vacation.response.default": "Use default handle",
  "vacation.response.custom": "Custom Handle",
  "vacation.help": "The \"vacation\" action implements a vacation autoresponder similar to the vacation command available under many versions of Unix. Its purpose is to provide correspondents with notification that the user is away for an extended period of time and that they should not expect quick responses.\n\n\"Vacation\" is used to respond to a message with another message. Vacation's messages are always addressed to the Return-Path address (that is, the envelope from address) of the message being responded to.",
  "vacation.summary": "Send a vacation/an out of office message:",
  "environment.tab.home": "Environment",
  "environment.tab.advanced": "Advanced",
  "environment.tab.help": "Help",
  "environment.name": "The environment info named...",
  "environment.name.domain": "Primary DNS domain of the machine where the Sieve script is executing",
  "environment.name.host": "Fully-qualified domain name of the host where the Sieve script is executing",
  "environment.name.location": "Provides additional information about the type of service that is evaluating the script.\nWell known services are \"MTA\" (Message Transfer Agent), \"MDA\" (Mail Delivery Agent),\n\"MUA\" (Mail User Agent) and \"MS\" (Message Store).",
  "environment.name.name": "Sieve interpreter's name.",
  "environment.name.phase": "Current delivery phase.\nCan be before (\"pre\"), during (\"during\"), and after final delivery (\"post\")",
  "environment.name.remotehost": "Host name of remote client as a Fully Qualified Domain Name (FQDN)\nAn empty string means, sieve failed to obtain this information",
  "environment.name.remoteip": "IP address of remote client in standard notation",
  "environment.name.version": "The Sieve interpreter's version number.",
  "environment.keys": "... any of the following keys...",
  "environment.help": "The environment test retrieves the item of environment information specified by the name string and matches it to the values specified in the key-list argument. The test succeeds if a match occurs.\n\n The current message is not a direct source of information for the environment test; the item of information specified by the name string is extracted from the script's operating environment and the key-list argument comes from the script.",
  "environment.summary": "Environment info named",
  "pipe.tab.home": "Pipe",
  "pipe.tab.help": "Help",
  "pipe.program.label": "Pipe the message to the program",
  "pipe.program.placeholder": "The program to be executed",
  "pipe.program.invalid": "The program name is invalid.",
  "pipe.arguments.label": "Pass arguments",
  "pipe.arguments.text": "Command line arguments to be passed to the external program.",
  "pipe.try.label": "Fail silently",
  "pipe.try.text": "Do not trigger an error in case executing the program failed.",
  "pipe.copy.label": "Keep a copy",
  "pipe.copy.text": "Do not cancel the implicit keep.",
  "pipe.help": "Pipe executes an external program on the server and pipes the messag into this program.\n\nIn case the program terminated without an error, the implicit keep will be canceled.",
  "pipe.summary": "Pipe message to",
  "filter.tab.home": "Filter",
  "filter.tab.help": "Help",
  "filter.program.label": "Run message through filter program",
  "filter.program.placeholder": "The program to be executed",
  "filter.program.invalid": "The program name is invalid.",
  "filter.arguments.label": "Pass arguments",
  "filter.arguments.text": "Command line arguments to be passed to the external program.",
  "filter.help": "The filter action executes an external program. The current message is forwarded to the program to process it. The ouput replaces the old message.\n\nThe filter action does not affect the implicit keep.\n\nIn case the program terminates with an error, the message it left unchanged.",
  "filter.summary": "Run message through filter program",
  "filter.summary.test.pre": "Message ran through filter program ",
  "filter.summary.test.post": " without errors",
  "execute.tab.home": "Execute",
  "execute.tab.help": "Help",
  "execute.program.label": "Execute external program",
  "execute.program.placeholder": "The program to be executed",
  "execute.program.invalid": "The program name is invalid.",
  "execute.arguments.label": "Pass arguments",
  "execute.arguments.text": "Command line arguments to be passed to the external program.",
  "execute.input.label": "Pass data to the program",
  "execute.input.input.title": "Use custom string",
  "execute.input.placeholder": "Custom data to be passed.",
  "execute.input.input.text": "The string may contain variable subsitutions which will be resolved before passing the data.",
  "execute.input.pipe.title": "Use current message",
  "execute.output.label": "Capture output to variable",
  "execute.output.text": "The programs output will be stored into a sieve variable when the program exected finished without an error.",
  "execute.output.placeholder": "Variable name which stores the output.",
  "execute.help": "Executes an external program.\n\nThe optional input can be forwarded to the program as well as output can be returned from the script.",
  "execute.summary": "Run program ",
  "execute.summary.test.pre": "Program",
  "execute.summary.test.post": "ran without errors",
  "not.summary": "does not match"
}