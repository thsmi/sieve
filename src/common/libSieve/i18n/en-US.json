{
  "sidebar.actions" : "Actions",
  "sidebar.tests" : "Tests",
  "sidebar.operators" : "Operators",

  "debug.tab.script" : "Script",
  "debug.tab.capabilities" : "Capabilities",
  "debug.tab.advanced" : "Advanced",

  "debug.script.input" : "Input:",
  "debug.script.parse" : "Parse Sieve Script",
  "debug.script.result" : "Result:",
  "debug.script.update" : "Update Sieve Script",

  "debug.advanced.compact" : "Compact",

  "debug.capabilities.script" : "Load from Script",
  "debug.capabilities.none" : "Select None",
  "debug.capabilities.all" : "Select All",
  "debug.capabilities.apply" : "Apply",

  "stringlist.add" : "Add",

  "numeric.nounit" : "No Unit",
  "numeric.kilobytes" : "Kilobytes",
  "numeric.megabytes" : "Megabytes",
  "numeric.gigabytes" : "Gigabytes",

  "return.tab.help" : "Help",
  "return.help" : "",

  "stop.tab.help" : "Help",
  "stop.help" : "",

  "discard.tab.help" : "Help",
  "discard.help" : "",

  "keep.tab.help" : "Help",
  "keep.help" : "",

  "fileinto.tab.home" : "Fileinto",
  "fileinto.tab.help" : "Help",
  "fileinto.folder.label" : "Save the incoming message into folder:",
  "fileinto.folder.placeholder" : "Enter folder",
  "fileinto.folder.invalid" : "Invalid folder name",
  "fileinto.help.text" : "The mailbox name is typically a hierarchical name used to determine a folder on the server. So it is equivalent with the folder structure you can see in your mail client.\n\nThere is no precise definition how the hierarchical name is formed. It depends on your mail server implementation. Only the case-insensitive mailbox name INBOX is a special name reserved to mean \"the primary mailbox for this user on this server\".\n\nBut you should avoid using non-graphical characters, the list-wildcard characters (\"%\" and \"*\"), characters which are reserved by the server for the level of hierarchy (typically \"/\" or \".\") as well as \"#\" as \"&\" because they can have special meanings.",
  "fileinto.summary" : "Save message into: ${path}",

  "exists.tab.home" : "Exists",
  "exists.tab.help" : "Help",
  "exists.header.label" : "All headers exist:",
  "exists.help.text": "",
  "exists.summary" : "Headers ${headers} exist",

  "header.tab.home" : "Header",
  "header.tab.advanced" : "Advanced",
  "header.tab.help" : "Help",
  "header.header": "Any of the following header…",
  "header.keywords": "… any of the keywords…",
  "header.help" : "Compares headers against constant strings.\n\nYou typically use this test with headers containing subject line or a spam score.\n\nDo not use this test, if the header should be matched against a mail addresses. The result will be unreliable, as this test is not aware of display names. Use the address test instead.",
  "header.summary" : "Header ${headers} ${matchtype} ${keys}",


  "addheader.tab.home" : "Add Header",
  "addheader.tab.help" : "Help",
  "addheader.name" : "Create a new header…",
  "addheader.name.invalid" : "Invalid header name, has to be a non-empty 7-bit ASCII string.",
  "addheader.value" : "… with a value of…",
  "addheader.value.invalid" : "Invalid header value, has to be non-empty",
  "addheader.position" : "… and add as…",
  "addheader.first" : "… first header",
  "addheader.last" : "… last header",
  "addheader.help" : "Adds a new header to the message. The existing message header are untouched. By default, the header field is inserted at the beginning of the existing message header.",
  "addheader.hint" : "The header name is by definition a case insensitive 7-bit ASCII string. Leading and trailing whitespace are ignored. Headers with invalid names are silently ignored.",
  "addheader.summary" : "Add header ${name} with value ${value}",

  "deleteheader.tab.home" : "Delete Header",
  "deleteheader.tab.advanced" : "Advanced",
  "deleteheader.tab.help" : "Help",
  "deleteheader.position" : "Delete…",
  "deleteheader.all" : "… all…",
  "deleteheader.first": "… the first",
  "deleteheader.last": "… the last",
  "deleteheader.name" : "… header named…",
  "deleteheader.name.invalid" : "Invalid header name, has to be a non-empty 7-bit ASCII string.",
  "deleteheader.value": "… with…",
  "deleteheader.any": "… any value",
  "deleteheader.some": "… one of the following values…",
  "deleteheader.some.matchtype": "… which…",
  "deleteheader.some.keywords": "… any of the keywords…",
  "deleteheader.help": "By default, the deleteheader action deletes all occurrences of the named header field. The deleteheader action does not affect Sieve’s implicit keep.",
  "deleteheader.hint": "The header name is by definition a case insensitive 7-bit ASCII string. Leading and trailing whitespace are ignored. Headers with invalid names are silently ignored.",
  "deleteheader.summary" : "Remove header ${name}",
  "deleteheader.summary2" : "Remove header ${name} where the value ${matchtype} any of ${value}",

  "mailboxexists.tab.home" : "Mailbox exists",
  "mailboxexists.tab.help" : "Help",
  "mailboxexists.folders" : "All of the following mailboxes (folders) exist:",
  "mailboxexists.help" : "Verifies existence of mailboxes.\n\nTests if all mailbox folders listed exist in the mailstore and if delivery is possible. Delivery is possible means the user has access right and the is allowed to read and write the folder.\n\nNote that a successful \"mailboxexists\" test doesn't necessarily mean that a \"fileinto\" action on this mailbox would succeed. For example, the \"fileinto\" action might put user over quota.",
  "mailboxexists.summary" : "Mailboxes ${mailboxes} exist",

  "metadataexists.tab.home" : "Meta Data exists",
  "metadataexists.tab.help" : "Help",
  "metadataexists.folder" : "The mailbox (folder)…",
  "metadataexists.annotations" : "… has all of the following annotations:",
  "metadataexists.help" : "Checks a mailbox for annotations.\n\nThe test return true if all of the annotations exist (i.e., have non-NIL values) for the specified mailbox.\n\nExamples of annotations are the Administrator’s contact address (/admin) or the suggest interval to check mails (/checkperiod).",
  "metadataexists.summary" : "Mailbox ${mailbox} has all annotations ${annotations}",

  "metadata.tab.home" : "Meta Data",
  "metadata.tab.advanced" : "Advanced",
  "metadata.tab.help" : "Help",
  "metadata.annotation" : "The annotation…",
  "metadata.folder" : "… in mailbox/folder…",
  "metadata.matchtype" : "… has a value which…",
  "metadata.keys" : "… any of the following keys:",
  "metadata.help" : "",
  "metadata.summary" : "Annotation ${annotation} in folder ${mailbox} has a value which ${matchtype} any of ${keys}",

  "servermetadataexists.tab.home" : "Server Meta Data exists",
  "servermetadataexists.tab.help" : "Help",
  "servermetadataexists.annotations" : "The server has all of the following annotations:",
  "servermetadataexists.help" : "Checks a mailbox for annotations\n\nThe test is true if all of the server annotations listed in the annotations exist (i.e., have non-NIL values).",
  "servermetadataexists.summary" : "The server supports all annotations ${annotations}",

  "servermetadata.tab.home" : "Server Meta Data",
  "servermetadata.tab.advanced" : "Advanced",
  "servermetadata.tab.help" : "Help",
  "servermetadata.annotation" : "The server annotation…",
  "servermetadata.matchtype" : "… has a value which…",
  "servermetadata.keys" : "… any of the following keys:",
  "servermetadata.help" : "",
  "servermetadata.summary" : "Server annotation ${annotation} has a value which ${matchtype} any of ${keys}",

  "reject.tab.home" : "Reject",
  "reject.tab.help" : "Help",
  "reject.deprecated" : "Reject is unsafe and was replaced by the ereject.",
  "reject.reject" :"Reject incoming messages and reply the following reason:",
  "reject.help" :"Reject is replaced by the ereject and should not be used anymore, because it is unsafe. The ereject action is similar to reject, but will always favor protocol-level message rejection.",
  "reject.summary" : "Reject incoming messages and reply ${reason}",

  "set.tab.home" : "Set",
  "set.tab.advanced" : "Advanced",
  "set.tab.help" : "Help",
  "set.value" : "Store the value…",
  "set.variable" : "… into variable",
  "set.variable.invalid" : "Invalid variable name",
  "set.modifier": "Modifiers are used to change a variables' value. They are processed in the following order",
  "set.case": "Modify variable’s case",
  "set.case.text" : "Only the case of Latin characters (A-Z and a-z) are changed, other characters are ignored.",
  "set.case.upper" : "upper case",
  "set.case.lower" : "lower case",
  "set.first": "Modify variable’s first character",
  "set.first.text": "Only the first character’s case is changed, the rest of the string is unchanged.",
  "set.first.upper" : "upper case",
  "set.first.lower" : "lower case",
  "set.help" : "Stores the specified value in the variable identified by name.\n\nThe name has to be a constant string and conform to the syntax of variable-name. Variable names are case insensitive.\n\nModifiers are applied before it is stored in the variable. If more than one modifier is specified, they are applied according to this precedence list:\n\n • Variable’s case\n • Variable’s first character\n • Escape Wildcards\n • Count characters",
  "set.summary" : "Set variable ${variable} to ${value}",

  "ereject.tab.home" : "Reject",
  "ereject.tab.help" : "Help",
  "ereject.reject" : "Reject incoming messages and reply the following reason:",
  "ereject.help" : "",

  "string.tab.home" : "String",
  "string.tab.advanced" : "Advanced",
  "string.tab.help" : "Help",
  "string.variables" : "Any of the following strings…",
  "string.keywords" : "… any of the keywords…",
  "string.help" : "",
  "string.summary" : "Any string ${sources} ${matchtype} any of ${value}",

  "notify.tab.home" : "Notify",
  "notify.tab.advanced" : "Advanced",
  "notify.tab.help" : "Help",
  "notify.method" : "Use the Method…",
  "notify.method.tel" : "Send an SMS message to a phone",
  "notify.method.tel.text" : "e.g. tel:+14085551212",
  "notify.method.xmpp" : "Send an XMPP message",
  "notify.method.xmpp.text" : "e.g. xmpp:me@example.com?message;subject=SIEVE;body=You%20got%20mail",
  "notify.method.mail" : "Send an email message",
  "notify.method.mail.text" : "e.g. mailto:me@example.com",
  "notify.message.default" : "… to send the server’s default message",
  "notify.message.default.text" : "A default implementation-specific message is used. It contains at least the value of the \"From\" header field and the value of the \"Subject\".",
  "notify.message.custom" : "… to send a custom message",
  "notify.message.custom.text" : "The message data to be included in the notification. Implementations may shorten the message for technical or aesthetic reasons.",
  "notify.from" : "Override the default sender",
  "notify.from.text" : "The server’s default is normally the current user. You can override this, but in oder minimize/prevent forgery of the author value, the server implementations impose restrictions on what values can be specified.",
  "notify.importance" : "Override the default importance",
  "notify.importance.text" : "Only few protocols support an importance or priority at all. Refer to the method’s documentation for more details on how the importance is mapped.",
  "notify.importance.high" : "High",
  "notify.importance.normal" : "Normal",
  "notify.importance.low" : "Low",
  "notify.summary" : "Send notification",
  "notify.options" : "Set additional options",
  "notify.options.text" : "Additional options passed to the mechanism as key and value pairs. Refer to the specific mechanisms for more details.",
  "notify.help" : "Specifies that a notification should be sent to a user. The format of the notification is implementation-defined and is affected by the notification method used.\n\nThe notification method is identified by a URI. For example, the notification method can be a tel URI [TEL-URI] with a phone number to send SMS messages to, or an XMPP [XMPP] URI containing an XMPP identifiers [XMPP-URI]. The supported notification methods are site-specific, but support for the [MailTo] method is guaranteed.\n\nSieve scripts should check the supported methods using the valid_notify_method test to be sure that they only use supported ones.",
  "notify.help.alert" : "An implementation may enforce semantic restrictions on URIs. For example, to restrict phone numbers in a tel URI to a particular geographical region. This will cause a parser error.",

  "validnotifymethod.tab.home" : "Valid notify method",
  "validnotifymethod.tab.help" : "Help",
  "validnotifymethod.notifyuris" : "All notify methods are supported…",
  "validnotifymethod.help" : "",
  "validnotifymethod.summary" : "Notify methods ${uri} are supported",

  "redirect.tab.home" : "Redirect",
  "redirect.tab.help" : "Help",
  "redirect.address.label" : "Forward email to:",
  "redirect.address.placeholder" : "Enter mail",
  "redirect.address.invalid" : "Invalid redirect address",
  "redirect.help" : "Redirect forwards the message to the given address. It makes no changes to the message body or existing headers, but it may add new headers.\n\nThe envelope sender address on the outgoing message is chosen by the sieve implementation.\n\nImplementations may ignore a redirect action silently due to policy reasons.",
  "redirect.summary" : "Redirect message to ${address}",

  "stop.summary" : "End Script (Stop processing)",

  "discard.summary" : "Discard message silently",

  "keep.summary" : "Keep a copy in the main inbox",

  "size.tab.home" : "Size",
  "size.tab.help" : "Help",
  "size.description" : "Check if message size is…",
  "size.larger" : "larger",
  "size.smaller" : "smaller",
  "size.compare" : "… than…",
  "size.help" : "Compares the message size.\n\nTest the message size is greater or smaller than the given size. The size is measured in bytes, character encoding are ignored.\n\n",
  "size.help.warning" : "There is only a larger or smaller, no equals. A message with exactly 4000 bytes is neither larger nor smaller than 4000 bytes.",
  "size.summary" : "Message is ${relation} than ${size}",

  "envelope.tab.home" : "Envelope",
  "envelope.tab.advanced" : "Advanced",
  "envelope.tab.help" : "Help",
  "envelope.envelopes" : "Any of the following envelope fields…",
  "envelope.keywords" : "… any of the keywords…",
  "envelope.help" : "Compares fields against the a mail’s envelope\n\nThe envelop is equivalent to the mail delivery protocol. So it does not test against a real header. Instead uses trace information from the mail delivery protocol for specific values.\n\nA \"to\" tests the SMTP sender field \"RCPT TO\" a \"from\" the recipient \"MAIL FROM\".\n\nIt is difficult to fake and is the most reliant way to test from which address a message was send to or received. But the Envelope properties are only visible to the server, you can not see them inside your mail client.",
  "envelope.summary" : "Any of the envelope fields ${envelopes} ${matchtype} ${addresspart} ${keys}",


  "address.tab.home" : "Address",
  "address.tab.advanced" : "Advanced",
  "address.tab.help" : "Help",
  "address.headers" : "Any of the following header…",
  "address.keywords" : "… any of the keywords…",
  "address.help" : "Compares headers against E-Mail addresses.\n\nYou typically use test with headers like \"to\", \"from\", \"cc\" etc.\n\nAs this test is aware of e-mail addresses containing display names. A header containing '\"roadrunner\" <roadrunner@acme.example.com>' is considered to be equivalent to \"'roadrunner@acme.example.com\"\n\nIf the header should be matched against a string use the header test.",
  "address.summary" : "Address in any header ${headers} ${matchtype} ${addresspart} ${keys}",


  "allofanyof.tab.home": "AllOf/AnyOf",
  "allofanyof.tab.help": "Help",
  "allofanyof.label": "Consider the test as successful if…",
  "allofanyof.allof": "… all of the tests succeed",
  "allofanyof.anyof": "… any of the tests succeed",
  "allofanyof.help" : "",


  "boolean.tab.home" :"Boolean",
  "boolean.tab.help" : "Help",
  "boolean.label" :"Make this test always",
  "boolean.true" : "succeed (true)",
  "boolean.false" : "fail (false)",
  "boolean.help" : "The boolean test is of limited practical use. If it is set to true it will always succeed. If set to false it will always fail",
  "boolean.summary.true" : "is true",
  "boolean.summary.false" : "is false",

  "condition.if" : "if",
  "condition.else" : "else",
  "condition.elseif" : "elseif",

  "operator.allof.summary" : "All of the following:",
  "operator.anyof.summary" : "Any of the following:",

  "duplicate.tab.home" :"Duplicate",
  "duplicate.tab.tracking" : "Tracking",
  "duplicate.tab.expiration" : "Expiration",
  "duplicate.tab.help" : "Help",
  "duplicate.summary" : "is a duplicate",

  "duplicate.unique.label" : "The unique id is…",

  "duplicate.tracking.text" :  "Duplicate tracking considers only messages which are tagged with the same handle. The rational is to have multiple tracking policies. In case no handle it provided the server will use a default one. A custom handle can be any unique strings.",
  "duplicate.tracking.default" : "Use default handle",
  "duplicate.tracking.custom" : "Custom Handle",
  "duplicate.tracking.custom.invalid" : "Invalid custom handle",

  "duplicate.expiration.text" : "The server uses a duplicate message list to track duplicates. To keep this list small and fast, the list entries expire. After a list entry is expired it is no more considered as a Duplicate.",
  "duplicate.expiration.default" : "Use server’s default policy (usually 7 days)",
  "duplicate.expiration.custom.pre" : "Expire after",
  "duplicate.expiration.custom.post" : "seconds",
  "duplicate.expiration.custom.invalid" : "Invalid expiration time",

  "duplicate.time.text": "Expiration time uses either the point in time when the entry in the duplicate message list was created or the point in time when the duplicate message entry was last accessed.",
  "duplicate.time.created" : "The moment the entry was created",
  "duplicate.time.accessed" : "The timestamp of the most recent access",
  "duplicate.help" : "The main application for this test is handling duplicate deliveries commonly caused by mailing list subscriptions or redirected mail addresses.\n\nThe detection is normally performed by matching the message ID to an internal list of message IDs from previously delivered messages.\n\nFor more complex applications, the \"duplicate\" test can also use the content of a specific header field or other parts of the message.\n\nDuplicate deliveries are a common side effect of being subscribed to a mailing list. For example, if a member of the list decides to reply to both the user and the mailing list itself, the user will often get one copy of the message directly and another through the mailing list.",

  "return.summary" : "End current script and return to the parent script",

  "global.tab.home" : "Global",
  "global.tab.help" : "Help",
  "global.title" : "Export variables into the global namespace:",
  "global.help" : "",
  "global.summary" : "Define global variables ${variables}",

  "include.tab.home" : "Include",
  "include.tab.advanced" : "Advanced",
  "include.tab.help" : "Help",
  "include.name" : "Include script name:",
  "include.name.placeholder" : "Script name",
  "include.name.invalid" : "Invalid script name",
  "include.once.label" : "Include at most once",
  "include.once.text" : "Subsequent include calls to the same script are silently discarded",
  "include.optional.label" : "Script is optional",
  "include.optional.text" : "By default a include throws an error if the script is not found.\nIn case script flagged as optional and is missing, it will be silently skipped.",
  "include.storage" : "Storage Location",
  "include.personal.label" : "Personal (default)",
  "include.personal.text" : "Personal scripts are located in your personal and private Sieve repository.",
  "include.global.label" : "Global",
  "include.global.text" : "Global scripts are stored in a site-wide Sieve repository.\nIt is accessible to all users any typically provided and maintained by your administrator.",
  "include.help" : "",
  "include.summary.personal" : "Include personal script ${script}",
  "include.summary.global" : "Include global script ${script}",

  "date.tab.home" : "Date",
  "date.tab.timezone" : "Timezone",
  "date.tab.advanced" : "Advanced",
  "date.tab.help" : "Help",
  "date.header" : "Has a Header…",
  "date.datepart" : "… where the…",
  "date.keywords" : "… any of the keywords…",
  "date.help" : "The date/time information is extracted from the header, shifted to the specified time zone, and the value of the given date-part is determined.\n\nThe test returns true if the resulting string matches any of the strings specified in the key-list.\n\nThe date test returns false if the specified header field does not exist, the field exists but does not contain a syntactically valid date-time specification, the date-time isn't valid according to the rules of the calendar system (e.g., January 32nd, February 29 in a non-leap year), or the resulting string fails to match any key-list value\n\nUnlike the header and address tests, the date test can only be applied to a single header field at a time. If multiple header fields with the same name are present, only the first field that is found is used.",
  "date.summary" : "${datepart} in header ${header} ${matchtype} any of ${keys}",


  "currentdate.tab.home" : "Current Date",
  "currentdate.tab.timezone" : "Timezone",
  "currentdate.tab.advanced" : "Advanced",
  "currentdate.tab.help" : "Help",
  "currentdate.datepart" : "The current…",
  "currentdate.keyword" : "… any of the keywords…",
  "currentdate.help" : "The currentdate test is similar to the date test, except that it operates on the current date/time rather than a value extracted from the message header.\n\nThe test returns true if the current date matches any of the strings specified in the key-list. It returns false if the resulting string fails to match any key-list value.",
  "currentdate.summary" : "The current ${datepart} ${matchtype} any of ${keys}",


  "datepart.year" : "year",
  "datepart.year.text" : "\"0000\" … \"9999\"",
  "datepart.month" : "month",
  "datepart.month.text" : "\"01\" … \"12\"",
  "datepart.day" : "day",
  "datepart.day.text" : "\"01\" … \"31\"",
  "datepart.date" : "date",
  "datepart.date.text" : "\"yyyy-mm-dd\"",
  "datepart.hour" : "hour",
  "datepart.hour.text" : "\"00\" … \"23\"",
  "datepart.minute" : "minute",
  "datepart.minute.text" : "\"00\" … \"59\"",
  "datepart.second" : "second",
  "datepart.second.text" : "\"00\" … \"60\"",
  "datepart.time" : "time",
  "datepart.time.text" : "\"hh:mm:ss\"",
  "datepart.iso8601" : "iso8601",
  "datepart.iso8601.text" : "Restricted ISO 8601 Format (RFC3339)",
  "datepart.std11" : "std11",
  "datepart.std11.text" : "Internet Message Format (RFC2822)",
  "datepart.zone" : "zone",
  "datepart.zone.text" : "Time zone (\"+hhmm\" or \"-hhmm\")",
  "datepart.weekday" : "weekday",
  "datepart.weekday.text" : "\"0\" (Sunday) … \"6\" (Saturday)",
  "datepart.julian" : "Julian",
  "datepart.julian.text" : "days since 1858-11-17 0:00 UTC",


  "zone.original" : "Original zone",
  "zone.original.text" : "Use the time zone offset from the date-time value.",


  "zone.custom" : "Adjust Timezone",
  "zone.custom.text" : "Shift the zone offset from the date-time value.\n\nOffsets are written in the format ±[hh][mm]. They can range from -1200 to +1400 and represent whole numbers of hours. Few zones are offset by 30 or 45 minutes like e.g. −0330 or +0545",


  "convert.tab.home" : "Convert",
  "convert.tab.help" : "Help",
  "convert.from" : "Convert the media type",
  "convert.to" : "… into…",
  "convert.transcode" : "… and apply the following transcodings",
  "convert.transcode.text" : "Transcodings are defined in RFC5259 and used to change properties during conversion. For example, rescaling images or changing text encoding.",
  "convert.help" : "Converts the whole message or their part into the a new media type. It is typically used to convert text documents and images as described in RFC5259.\n\nTheoretically it would be possible to convert everything into anything (e.g. an audio file into text). But in reality your server will support only a very limited subset of conversions. Keep in mind conversion may require lots of resources and processing time e.g. when rescaling images or creating pdfs.\n\nIn case the conversion fails the message remains unchanged. If this method is used inside a test. The test will performing the conversion and evaluate if the conversion succeeded or failed.",
  "convert.summary": "Convert ${from} to ${to}",


  "body.tab.home" : "Body",
  "body.tab.transform" : "Transform",
  "body.tab.advanced" : "Advanced",
  "body.tab.help" : "Help",
  "body.matchtypes" : "The email’s message body…",
  "body.keylist" : "… any of the keywords…",
  "body.transform" : "Match against…",
  "body.help" : "The body test matches content in the body of an email message, that is, anything following the first empty line after the header. The empty line itself, if present, is not considered to be part of the body.",
  "body.summary" : "Message body ${matchtype} ${value}",


  "addflag.tab.home" : "Add Flag",
  "addflag.tab.help" : "Help",
  "addflag.flags.title" : "Add the following IMAP Flags…",
  "addflag.flags.text" : "It doesn't replace any previously set flags. This means that multiple occurrences of addflag are treated additively.",
  "addflag.help" : "Add flags to a message. It doesn't replace any previously set flags. This means that multiple occurrences of addflag are treated additively.\n\nMessage labels are called flags in the IMAP specification and are divided into two types: system flags and user-defined flags.\n\nSystem flags are defined in the IMAP Specification. They start with a leading backslash (\\). The current the following six system flags \\Seen, \\Answered, \\Flagged, \\Deleted, \\Draft, \\Recent are defined.\n\nUser-defined flags are also known as IMAP keywords and, as the name implies, are defined by IMAP users. There is a de facto standard that keywords which are in common use have names that begin with a dollar sign ($).\n\nExamples of common keywords are: $Label1, $Label2, $Label3, $Label4, $Label5. These keywords are typically hardwired to Important, Work, Personal, To Do and Later.\n\nIf you define your own personal keyword, its name should not begin with dollar sign ($) or backslash (\\) because otherwise it might collide with a flag that is used by current or future IMAP clients and servers.",
  "addflag.summary" : "Add IMAP flags ${flags}",

  "spamtest.tab.home" : "Spamtest",
  "spamtest.tab.advanced" : "Advanced",
  "spamtest.tab.help" : "Help",
  "spamtest.spamscore" : "The spam score…",
  "spamtest.help" : "",
  "spamtest.absolute.label": "… absolute value…",
  "spamtest.absolute.text": "By default Sieve uses a spam score ranging from 0 to 10 describing the likelihood to be spam. Where 0 means untested or spam-free and 10 means definitely spam.",
  "spamtest.absolute.nottested" : "Message was not tested for spam",
  "spamtest.absolute.nospam" : "Message is spam-free",
  "spamtest.absolute.likelyspan" : "Message’s spam likelihood",
  "spamtest.absolute.spam" : "Message definitely contains spam",
  "spamtest.percent.label" : "… percentual value…",
  "spamtest.percent.text" : "The spam score can also be a likelihood ranging from 0 to 100, where 0 means no spam or untested and 100 definitive spam.",
  "spamtest.percent.nospam" : "Message was not tested for spam or is spam-free",
  "spamtest.percent.likelyspan" : "Message’s spam likelihood in percent",
  "spamtest.percent.spam" : "Message definitely contains spam",
  "spamtest.summary" : "Spam score ${matchtype} ${score}",


  "hasflag.tab.home" : "Has Flag",
  "hasflag.tab.advanced" : "Advanced",
  "hasflag.tab.help" : "Help",
  "hasflag.flags.title" : "An IMAP flag…",
  "hasflag.flags.keyword" : "… any of the keywords…",
  "hasflag.help" : "Checks if a message is tagged with an IMAP flag or label.\n\nMessage labels are called flags in the IMAP specification and are divided into two types: system flags and user-defined flags.\n\nSystem flags are defined in the IMAP Specification. They start with a leading backslash (\\). The current the following six system flags \\Seen, \\Answered, \\Flagged, \\Deleted, \\Draft, \\Recent are defined.\n\nUser-defined flags are also known as IMAP keywords and, as the name implies, are defined by IMAP users. There is a de facto standard that keywords which are in common use have names that begin with a dollar sign ($).\n\nExamples of common keywords are: $Label1, $Label2, $Label3, $Label4, $Label5. These keywords are typically hardwired to Important, Work, Personal, To Do and Later.\n\nIf you define your own personal keyword, its name should not begin with dollar sign ($) or backslash (\\) because otherwise it might collide with a flag that is used by current or future IMAP clients and servers.",
  "hasflag.summary" : "Has IMAP flags ${flags}",

  "removeflag.tab.home" : "Remove Flag",
  "removeflag.tab.help" : "Help",
  "removeflag.flags.title" : "Remove the following IMAP Flags…",
  "removeflag.flags.text" : "Removeflag clears flags previously set by setflag or addflag",
  "removeflag.help" : "Removeflag clears flags previously set by \"setflag\" or \"addflag\". Calling removeflag with a flag that wasn't set before is not an error and is ignored.\n\nMessage labels are called flags in the IMAP specification and are divided into two types: system flags and user-defined flags.\n\nSystem flags are defined in the IMAP Specification. They start with a leading backslash (\\). The current the following six system flags \\Seen , \\Answered, \\Flagged, \\Deleted, \\Draft, \\Recent are defined.\n\nUser-defined flags are also known as IMAP keywords and, as the name implies, are defined by IMAP users. There is a de facto standard that keywords which are in common use have names that begin with a dollar sign ($).\n\nExamples of common keywords are: $Label1, $Label2, $Label3, $Label4, $Label5. These keywords are typically hardwired to Important, Work, Personal, To Do and Later.\n\nIf you define your own personal keyword, its name should not begin with dollar sign ($) or backslash (\\) because otherwise it might collide with a flag that is used by current or future IMAP clients and servers.",
  "removeflag.summary" : "Remove IMAP flags ${flags}",

  "setflags.tab.home" : "Set Flag",
  "setflags.tab.help" : "Help",
  "setflags.flags.title": "Set the following IMAP Flags…",
  "setflags.flags.text": "It replaces any previously set flags.",
  "setflag.help":"Setflag is used for setting system flags, it replaces any previously set flags.\n\nMessage labels are called flags in the IMAP specification and are divided into two types: system flags and user-defined flags.\n\nSystem flags are defined in the IMAP Specification. They start with a leading backslash (\\). The current the following six system flags \\Seen , \\Answered, \\Flagged, \\Deleted, \\Draft, \\Recent are defined.\n\nUser-defined flags are also known as IMAP keywords and, as the name implies, are defined by IMAP users. There is a de facto standard that keywords which are in common use have names that begin with a dollar sign ($).\n\nExamples of common keywords are: $Label1, $Label2, $Label3, $Label4, $Label5. These keywords are typically hardwired to Important, Work, Personal, To Do and Later.\n\nIf you define your own personal keyword, its name should not begin with dollar sign ($) or backslash (\\) because otherwise it might collide with a flag that is used by current or future IMAP clients and servers.",
  "setflag.summary" : "Set IMAP flags ${flags}",

  "flags.label" : "Add IMAP flag",
  "flags.text" : "Adds flags to a message. It doesn't replace any previously set flags.",

  "copy.label" : "Keep a copy",
  "copy.text" : "By default the action cancels the implicit keep statement. So that it won't be stored in the inbox after processing. When activating a copy of the original message is kept in the inbox.",

  "create.label" : "Create folder, when non existent",

  "unique.default.title" : "… extracted from the header named message-id.",
  "unique.default.text" : "The message-id is assumed but not guaranteed to be globally unique.",

  "unique.header.title" : "… extracted from the header named:",
  "unique.header.text" : "Often mailinglist or ticket system use special headers to track duplicates.",

  "unique.id.title" : "… is provided:",
  "unique.id.text" : "Using a static string does not sound too useful. But in combination with sieve variables, the string will get virtually dynamic. And you are able to create almost any unique id pattern to match against.",


  "bodyTransform.contentType" : "… the MIME parts that have the specified content types:",
  "bodyTransform.text" : "… the decoded message body. (Default)",
  "bodyTransform.raw" : "… the entire undecoded message body",

  "matchtype.is.title" : "… is…",
  "matchtype.is.text" : "Only \"frobnitzm\" is \"frobnitzm\"",

  "matchtype.contains.title" : "… contains…",
  "matchtype.contains.text" : "\"frobnitzm\" contains \"frob\" and \"nit\", but not \"fbm\"",

  "matchtype.matches.title" : "… matches…",
  "matchtype.matches.text" : "\"*\" matches zero or more characters, a \"?\" matches a single character\n\"frobnitzm\" matches \"frob*zm\" or \"frobnit?m\" but not \"frob?m\"",

  "matchtype.value.title" : "… is",
  "matchtype.value.title2" : "…",
  "matchtype.value.greater" : "greater than",
  "matchtype.value.greaterEqual" : "greater than or equal",
  "matchtype.value.less" : "less than",
  "matchtype.value.lessEqual" : "less than or equal",
  "matchtype.value.equal" : "equal to",
  "matchtype.value.notEqual" : "not equal to",
  "matchtype.value.text" : "Compares the relation between strings. The test is considered true if any pair is true",

  "matchtype.regex.title" : "… regex matches…",
  "matchtype.regex.text" : "Matches and compares using on a regular expression as defined in IEEE.1003-2.1992",

  "matchtype.count.title" : "… has",
  "matchtype.count.title2" : "items…",
  "matchtype.count.greater" : "greater than",
  "matchtype.count.greaterEqual" : "greater than or equal",
  "matchtype.count.less" : "less than",
  "matchtype.count.lessEqual" : "less than or equal",
  "matchtype.count.equal" : "equal to",
  "matchtype.count.notEqual" : "not equal to",
  "matchtype.count.text" : "Counts the number of entities and compares them to the given value",

  "modifier.length.title" : "Count characters",
  "modifier.length.text" : "Variables are expanded before determining the number of characters.",

  "modifier.quotewildcard.title" : "Escape Wildcards",
  "modifier.quotewildcard.text" : "Ensures that the expanded text will only match a literal occurrence if used as a parameter to :matches. Every character with special meaning (\"*\", \"?\", and \"\\\") is prefixed with \"\\\" in the expansion.",

  "modifier.encodeurl.title" : "URL Encode" ,
  "modifier.encodeurl.text" : "URL encodes the variable. This means it performs percent-encoding of any octet in the string that doesn't belong to the \"unreserved\" set (see [URI])." ,

  "addresspart.all.title" : "… an email address with…",
  "addresspart.all.text" : "An email address consists of a local-part and a domain separated by the \"@\" sign.\nThe local-part is case sensitive while the domain part is not.",

  "addresspart.domain.title" : "… a domain part with…",
  "addresspart.domain.text" : "Everything after the @ sign. The domain part is not case sensitive.\ne.g.: \"me@example.com\" is stripped to \"example.com\"",

  "addresspart.local.title" : "… a local-part with…",
  "addresspart.local.text" : "Everything before the @ sign. The local-part is case sensitive.\ne.g.: \"me@example.com\" is stripped to \"me\"",

  "addresspart.user.title" : "… a user sub-part with…",
  "addresspart.user.text" : "Everything before the + sign or between the -- sequence and the @sign.\nThe local-part is case sensitive.\ne.g.: \"user+detail@example.com\" or \"detail--user@example.com\" is stripped to \"user\"",

  "addresspart.detail.title" : "… a detail sub-part with…",
  "addresspart.detail.text" : "Everything between the + sign and the @ sign, or before a -- sequence.\nThe local-part is case sensitive.\ne.g.: \"user+detail@example.com\" or \"detail--user@example.com\" is stripped to \"detail\"",

  "comparator.asciicasemap.title" : "Case insensitive (default)",
  "comparator.asciicasemap.text" : "Treats uppercase and lowercase ASCII characters as the same.\nAll non ASCII characters are compared byte by byte.",

  "comparator.asciinumeric.title" : "Numeric",
  "comparator.asciinumeric.text" : "Converts the string to an integer and does a numeric compare.",

  "comparator.octet.title" : "Case sensitive",
  "comparator.octet.text" : "Compares the string byte by byte.",

  "interval.days.label.pre": "Reply at most every",
  "interval.days.label.post": "days",

  "interval.default.label":"Use Server’s default policy",

  "interval.seconds.label.pre":"Reply at most every",
  "interval.seconds.label.post":"seconds",

  "virustest.tab.home" : "Virustest",
  "virustest.tab.advanced" : "Advanced",
  "virustest.tab.help" : "Help",
  "virustest.title" : "The virus scan result…",
  "virustest.nottested" : "Message was not tested for viruses",
  "virustest.notinfected" : "Message was tested and contains no known viruses",
  "virustest.sanitized" : "Message contained a known virus that was replaced with harmless content",
  "virustest.cured" : "Message contained a known virus that was \"cured\" such that it is now harmless",
  "virustest.likelyinfected" : "Message possibly contains a known virus",
  "virustest.infected" : "Message was tested and definitely contains a known virus",
  "virustest.help" : "The \"virustest\" test evaluates to true if the normalized result string matches the value.\n\nThe normalized result string starts with a numeric value in the range \"0\" (zero) through \"5\", with meanings summarized below:",
  "virustest.summary" : "Virus check ${matchtype} ${score}",

  "vacation.tab.home" : "Vacation",
  "vacation.tab.envelope" : "Envelope",
  "vacation.tab.advanced" : "Advanced",
  "vacation.tab.help" : "Help",

  "vacation.envelope.subject" : "Subject:",
  "vacation.envelope.subject.default" : "Server’s default Subject",
  "vacation.envelope.from" : "From:",
  "vacation.envelope.from.default" : "Address of the sieve script owner",
  "vacation.envelope.addresses" : "Addresses:",
  "vacation.envelope.text" : "Enter your vacation message",

  "vacation.subject" : "Subject",
  "vacation.subject.text" : "The subject is used for any vacation response",
  "vacation.subject.default" : "Server’s default Subject",
  "vacation.subject.custom" : "Custom Subject",

  "vacation.from" : "From address",
  "vacation.from.text" : "Used to specify an alternate From address.",
  "vacation.from.default" : "Address of the sieve script owner",
  "vacation.from.custom" : "Custom From Address",

  "vacation.addresses" : "Additional recipients addresses",
  "vacation.addresses.text" : "By default a response message is only send, if it was addressed to the recipient user or sieve script owner.\nYou can supply additional mail addresses. For example, if mails are forwarded or you have multiple aliases for a single mail address",

  "vacation.contenttype" : "Message Content Type",
  "vacation.contenttype.text" : "Instead of plaintext, the message can be a specified as a MIME Message",
  "vacation.contenttype.default" : "Is plaintext Message (Default)",
  "vacation.contenttype.mime" : "Is MIME Message",

  "vacation.tracking" : "Response Tracking",
  "vacation.tracking.text" : "A vacation message is sent at most every some days to the same sender",

  "vacation.response" : "Response Handles",
  "vacation.response.text" : "The response tracking considers all vacation statements that use the same handle as the same response\nThe default handle considers subject, from, mime as well as the message. A custom handle can be any unique strings",
  "vacation.response.default" : "Use default handle",
  "vacation.response.custom" : "Custom Handle",

  "vacation.help" : "The \"vacation\" action implements a vacation autoresponder similar to the vacation command available under many versions of Unix. Its purpose is to provide correspondents with notification that the user is away for an extended period of time and that they should not expect quick responses.\n\n\"Vacation\" is used to respond to a message with another message. Vacation’s messages are always addressed to the Return-Path address (that is, the envelope from address) of the message being responded to.",
  "vacation.summary" : "Send a vacation/an out of office message: ${reason}",

  "environment.tab.home" : "Environment",
  "environment.tab.advanced" : "Advanced",
  "environment.tab.help" : "Help",
  "environment.name" : "The environment info named…",
  "environment.name.domain" : "Primary DNS domain of the machine where the Sieve script is executing",
  "environment.name.host" : "Fully-qualified domain name of the host where the Sieve script is executing",
  "environment.name.location" : "Provides additional information about the type of service that is evaluating the script.\nWell known services are \"MTA\" (Message Transfer Agent), \"MDA\" (Mail Delivery Agent),\n\"MUA\" (Mail User Agent) and \"MS\" (Message Store).",
  "environment.name.name" : "Sieve interpreter’s name.",
  "environment.name.phase" : "Current delivery phase.\nCan be before (\"pre\"), during (\"during\"), and after final delivery (\"post\")",
  "environment.name.remotehost" : "Host name of remote client as a Fully Qualified Domain Name (FQDN)\nAn empty string means, sieve failed to obtain this information",
  "environment.name.remoteip" : "IP address of remote client in standard notation",
  "environment.name.version" : "The Sieve interpreter’s version number.",
  "environment.keys" : "… any of the following keys…",
  "environment.help" : "The environment test retrieves the item of environment information specified by the name string and matches it to the values specified in the key-list argument. The test succeeds if a match occurs.\n\nThe current message is not a direct source of information for the environment test; the item of information specified by the name string is extracted from the script’s operating environment and the key-list argument comes from the script.",
  "environment.summary" : "Environment info named ${name} ${matchtype} ${keys}",

  "pipe.tab.home" : "Pipe",
  "pipe.tab.help" : "Help",
  "pipe.program.label" : "Pipe the message to the program",
  "pipe.program.placeholder" : "The program to be executed",
  "pipe.program.invalid" : "The program name is invalid.",
  "pipe.arguments.label" : "Pass arguments",
  "pipe.arguments.text" : "Command line arguments to be passed to the external program.",
  "pipe.try.label" : "Fail silently",
  "pipe.try.text" : "Do not trigger an error in case executing the program failed.",
  "pipe.copy.label" : "Keep a copy",
  "pipe.copy.text" :  "Do not cancel the implicit keep.",
  "pipe.help" : "Pipe executes an external program on the server and pipes the messag into this program.\n\nIn case the program terminated without an error, the implicit keep will be canceled.",
  "pipe.summary" : "Pipe message to ${program}",

  "filter.tab.home" : "Filter",
  "filter.tab.help" : "Help",
  "filter.program.label" : "Run message through filter program",
  "filter.program.placeholder" : "The program to be executed",
  "filter.program.invalid" : "The program name is invalid.",
  "filter.arguments.label" : "Pass arguments",
  "filter.arguments.text" : "Command line arguments to be passed to the external program.",
  "filter.help" : "The filter action executes an external program. The current message is forwarded to the program to process it. The ouput replaces the old message.\n\nThe filter action does not affect the implicit keep.\n\nIn case the program terminates with an error, the message it left unchanged.",
  "filter.summary" : "Run message through filter program ${program}",
  "filter.summary.test" : "Message ran through filter program ${program} without errors",

  "execute.tab.home" : "Execute",
  "execute.tab.help" : "Help",
  "execute.program.label" : "Execute external program",
  "execute.program.placeholder" : "The program to be executed",
  "execute.program.invalid" : "The program name is invalid.",
  "execute.arguments.label" : "Pass arguments",
  "execute.arguments.text" : "Command line arguments to be passed to the external program.",
  "execute.input.label" : "Pass data to the program",
  "execute.input.input.title" : "Use custom string",
  "execute.input.placeholder" : "Custom data to be passed.",
  "execute.input.input.text" : "The string may contain variable subsitutions which will be resolved before passing the data.",
  "execute.input.pipe.title" : "Use current message",
  "execute.output.label" : "Capture output to variable",
  "execute.output.text" : "The programs output will be stored into a sieve variable when the program exected finished without an error.",
  "execute.output.placeholder" : "Variable name which stores the output.",
  "execute.help" : "Executes an external program.\n\nThe optional input can be forwarded to the program as well as output can be returned from the script.",
  "execute.summary" : "Run Program ${program}",
  "execute.summary.test" : "Program ${program} ran without errors",

  "not.summary" : "does not match",

  "notifymethodcapability.tab.home" : "Notify Method Capability",
  "notifymethodcapability.tab.advanced" : "Advanced",
  "notifymethodcapability.tab.help" : "Help",
  "notifymethodcapability.method" : "Check if method’s…",
  "notifymethodcapability.method.tel" : "Send an SMS message to a phone",
  "notifymethodcapability.method.tel.text" : "e.g. tel:+14085551212",
  "notifymethodcapability.method.xmpp" : "Send an XMPP message",
  "notifymethodcapability.method.xmpp.text" : "e.g. xmpp:me@example.com?message;subject=SIEVE;body=You%20got%20mail",
  "notifymethodcapability.method.mail" : "Send an email message",
  "notifymethodcapability.method.mail.text" : "e.g. mailto:me@example.com",
  "notifymethodcapability.capability" : "… notification capability…",
  "notifymethodcapability.keywords" : "… any of the keywords…",
  "notifymethodcapability.yes" : "yes",
  "notifymethodcapability.yes.text" : "The entity identified by the notification-uri can receive a notify notification.",
  "notifymethodcapability.no" : "no",
  "notifymethodcapability.no.text" : "The entity identified by the notification-uri is currently not available to receive an immediate notification.",
  "notifymethodcapability.maybe" : "maybe",
  "notifymethodcapability.maybe.text" : "The Sieve interpreter can't determine if the entity identified by the notification-uri is online or not",
  "notifymethodcapability.help" :"The notify_method_capability test retrieves the notification capability for given method and matches it to the given values.\n\nThe capability parameter is case insensitive. Currently only a single capability \"online\" is defined. But Sieve Notifications extensions may add aditional capabilities.\n\nThe \"online\" capabilities result is either \"yes\", \"no\" or \"maybe\". And describes the likelyness for a successfull delivery.\n\nNote that even after a \"yes\", there is no guarantee when and if the notification is received. Transport errors, recipient policy, etc. can prevent that.",
  "notifymethodcapability.summary" :"Check the notification capabilities."

}