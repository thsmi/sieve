{
  "sidebar.actions": "Aktionen",
  "sidebar.tests": "Bedingungen",
  "sidebar.operators": "Operatoren",
  "debug.tab.script": "Skript",
  "debug.tab.capabilities": "Capabilities",
  "debug.tab.advanced": "Erweitert",
  "debug.script.input": "Eingabe:",
  "debug.script.parse": "Parse Sieve Script",
  "debug.script.result": "Ausgabe:",
  "debug.script.update": "Update Sieve Script",
  "debug.advanced.compact": "Komprimieren",
  "debug.capabilities.script": "Aus Skript laden",
  "debug.capabilities.none": "Nichts auswählen",
  "debug.capabilities.all": "Alles auswählen",
  "debug.capabilities.apply": "Anwenden",
  "stringlist.add": "Neuer Eintrag",
  "numeric.nounit": "Ohne Einheit",
  "numeric.kilobytes": "Kilobytes",
  "numeric.megabytes": "Megabytes",
  "numeric.gigabytes": "Gigabytes",
  "return.tab.help": "Hilfe",
  "return.help": "",
  "stop.tab.help": "Hilfe",
  "stop.help": "",
  "discard.tab.help": "Hilfe",
  "discard.help": "",
  "keep.tab.help": "Hilfe",
  "keep.help": "",
  "fileinto.tab.home": "Fileinto",
  "fileinto.tab.help": "Hilfe",
  "fileinto.folder.label": "Die eingehende Nachricht im folgenden Ordner speichern:",
  "fileinto.folder.placeholder": "Bitte Ordnernamen eingeben",
  "fileinto.folder.invalid": "Der Ordnername ist ungültig!",
  "fileinto.help.text": "The mailbox name is typically a hierarchical name used to determine a folder on the server. So it is equivalent with the folder structure you can see in your mail client.\n\nThere is no precise definition how the hierarchical name is formed. It depends on your mail server implementation. Only the case-insensitive mailbox name INBOX is a special name reserved to mean \"the primary mailbox for this user on this server\".\n\nBut you should avoid using non-graphical characters, the list-wildcard characters (\"%\" and \"*\"), characters which are reserved by the server for the level of hierarchy (typically \"/\" or \".\") as well as \"#\" as \"&\" because they can have special meanings.",
  "fileinto.summary": "Save message into:",
  "exists.tab.home": "Exists",
  "exists.tab.help": "Hilfe",
  "exists.header.label": "Alle folgenden Kopfzeilen existieren:",
  "exists.help.text": "",
  "exists.summary1": "Header(s)",
  "exists.summary2": "exist",
  "header.tab.home": "Header",
  "header.tab.advanced": "Erweitert",
  "header.tab.help": "Hilfe",
  "header.header": "Eine der folgenden Kopfzeilen...",
  "header.keywords": "... eines der folgenden Schlüsselwörter",
  "header.help": "Vergleicht eine Kopfzeilen mit einer Zeichenkette. Es eignet sich für Text wie z.B. die Betreffzeile oder die Spam Score.\n\nDer Test ist ungeeignet um E-Mailadressen zu vergleichen. Kopfzeilen mit E-Mailadressen verwenden einen speziellen Syntax, der aus einem optionalen Anzeigenamen und der Adresse besteht. Verwenden Sie stattdessen den 'address' test, er wertet E-Mailadressen korrekt aus.",
  "header.summary": "header",
  "addheader.tab.home": "Add Header",
  "addheader.tab.help": "Hilfe",
  "addheader.name": "Erstellt eine neues Kopfzeile...",
  "addheader.name.invalid": "Die Kopfzeile ist ungültig, der Name muss ein nicht 7bit ASCII-String sein.",
  "addheader.value": "... mit einem Wert von ...",
  "addheader.value.invalid": "Ungültiger Wert. Der Wert einer Kopfzeile darf nicht leer sein.",
  "addheader.position": "... and add as ...",
  "addheader.first": "... erste Kopfzeile",
  "addheader.last": "... letzte Kopfzeile",
  "addheader.help": "Fügt der Nachricht einen neuen Kopfzeile hinzu. Der vorhandene Kopfzeilen bleibt unberührt. Standardmäßig wird die Kopfzeile vor den existierenden Kopfzeilen eingefügt.",
  "addheader.hint": "Der Kopfzeilenname muss eine 7bit US-ASCII-Zeichenkette. Groß/Kleinschreibung wird nicht unterschieden, ebenso werden Leerzeichen am Zeilenanfang und -ende ignoriert. Kopfzeilen mit ungültigen Namen werden stillschweigend ignoriert.",
  "addheader.summary1": "Add header",
  "addheader.summary2": "with value",
  "deleteheader.tab.home": "Delete Header",
  "deleteheader.tab.advanced": "Erweitert",
  "deleteheader.tab.help": "Hilfe",
  "deleteheader.position": "Delete ...",
  "deleteheader.all": "... alle ...",
  "deleteheader.first": "... the first",
  "deleteheader.last": "... the last",
  "deleteheader.name": "... header named ...",
  "deleteheader.name.invalid": "Invalid header name, has to be a non empty 7bit ASCII string",
  "deleteheader.value": "... with ...",
  "deleteheader.any": "... any value",
  "deleteheader.some": "... one of the following values ...",
  "deleteheader.some.matchtype": "... which ...",
  "deleteheader.some.keywords": "... any of the keyword(s):",
  "deleteheader.help": "By default, the deleteheader action deletes all occurrences of the named header field. The deleteheader action does not affect Sieve's implicit keep",
  "deleteheader.hint": "The header name is by definition a case insensitive 7bit US-ASCII string. Leading and tailing whitespace are ignored. Headers with invalid names are silently ignored.",
  "deleteheader.summary1": "Remove a header",
  "deleteheader.summary2": "with a value",
  "mailboxexists.tab.home": "Mailbox exists",
  "mailboxexists.tab.help": "Hilfe",
  "mailboxexists.folders": "All of the following mailboxes (folders) exist:",
  "mailboxexists.help": "Verifies existence of mailboxes\n\nTests if all mailbox folders listed exist in the mailstore and if delivery is possible. Delivery is possible means the user has access right and the is allowed to read and write the folder.\n\n Note that a successful \"mailboxexists\" test doesn't necessarily mean that a \"fileinto\" action on this mailbox would succeed. For example, the \"fileinto\" action might put user over quota.",
  "mailboxexists.summary1": "Mailbox(es)",
  "mailboxexists.summary2": "exists",
  "metadataexists.tab.home": "Meta Data exists",
  "metadataexists.tab.help": "Hilfe",
  "metadataexists.folder": "The mailbox (folder) ...",
  "metadataexists.annotations": "... has all of the following annotations:",
  "metadataexists.help": "Checks a mailbox for annotations\n\nThe test return true if all of the annotations exist (i.e., have non-NIL values) for the specified mailbox.",
  "metadataexists.summary1": "Mailbox",
  "metadataexists.summary2": "has all annotations",
  "metadata.tab.home": "Meta Data",
  "metadata.tab.advanced": "Erweitert",
  "metadata.tab.help": "Hilfe",
  "metadata.annotation": "The annotation ...",
  "metadata.folder": "... in mailbox/folder ...",
  "metadata.matchtype": "... has a value which ...",
  "metadata.keys": "... any of the following keys:",
  "metadata.help": "",
  "metadata.summary1": "Annotation",
  "metadata.summary2": "in folder",
  "metadata.summary3": "has a value which",
  "metadata.summary4": "any of",
  "servermetadataexists.tab.home": "Server Meta Data exists",
  "servermetadataexists.tab.help": "Hilfe",
  "servermetadataexists.annotations": "The server has all of the following annotations:",
  "servermetadataexists.help": "Checks a mailbox for annotations\n\nThe test is true if all of the server annotations listed in the annotations exist (i.e., have non-NIL values).",
  "servermetadataexists.summary": "The server supports annotations ",
  "servermetadata.tab.home": "Server Meta Data",
  "servermetadata.tab.advanced": "Erweitert",
  "servermetadata.tab.help": "Hilfe",
  "servermetadata.annotation": "The server annotation ... ",
  "servermetadata.matchtype": "... has a value which ...",
  "servermetadata.keys": "... any of the following keys:",
  "servermetadata.help": "",
  "servermetadata.summary1": "Server annotation",
  "servermetadata.summary2": "has a value which",
  "servermetadata.summary3": "any of",
  "reject.tab.home": "Reject",
  "reject.tab.help": "Hilfe",
  "reject.deprecated": "Reject ist unsicher und wurde durch das ereject ersetzt.",
  "reject.reject": "Reject incoming messages and reply the following reason:",
  "reject.help": "'reject' ist unsicher und wurde durch 'ereject' ersetzt. Es sollte daher nicht mehr verwendet werden. Ein 'ereject' weist Nachrichten auf Protokollebene zurück und Arbeit daher zuverlässiger.",
  "reject.summary": "Reject incoming messages and reply the following reason:",
  "set.tab.home": "Set",
  "set.tab.advanced": "Erweitert",
  "set.tab.help": "Hilfe",
  "set.value": "Store the value ...",
  "set.variable": "... into variable",
  "set.variable.invalid": "Ungültiger Variablennamen\n",
  "set.modifier": "Modifiers are used to change a variables' value. They are processed in the following order",
  "set.case": "Modify variable's case",
  "set.case.text": "Es werden nur die Zeichen (A-Z und a-z) geändert, keine Umlaute oder ähnliches.",
  "set.case.upper": "upper case",
  "set.case.lower": "lower case",
  "set.first": "Modify variable's first character",
  "set.first.text": "Only the first character's case is changed, the rest of the string is unchanged.",
  "set.first.upper": "upper case",
  "set.first.lower": "lower case",
  "set.help": "Stores the specified value in the variable identified by name.\n\n The name has to be a constant string and conform to the syntax of variable-name. Variable names are case insensitive.\n\n Modifiers are applied before it is stored in the variable. If more than one modifier is specified, they are applied according to this precedence list:\n\n • Variable's case\n • Variable's first character\n • Escape Wildcards\n • Count characters\n",
  "set.summary1": "Set variable",
  "set.summary2": "to value",
  "ereject.tab.home": "Reject",
  "ereject.tab.help": "Hilfe",
  "ereject.reject": "Reject incoming messages and reply the following reason:",
  "ereject.help": "",
  "string.tab.home": "String",
  "string.tab.advanced": "Erweitert",
  "string.tab.help": "Hilfe",
  "string.variables": "Any of the following strings ...",
  "string.keywords": "... any of the keyword(s):",
  "string.help": "",
  "string.summary": "string",
  "notify.tab.home": "Notify",
  "notify.tab.advanced": "Erweitert",
  "notify.tab.help": "Hilfe",
  "notify.method": "Use the Method...",
  "notify.method.tel": "Senden eine SMS an eine Telefonnummer",
  "notify.method.tel.text": "z.B. tel:+14085551212",
  "notify.method.xmpp": "Sende ein xmpp Nachricht",
  "notify.method.xmpp.text": "z.B. xmpp:me@example.com?message;subject=SIEVE;body=You%20got%20mail",
  "notify.method.mail": "Sende eine E-Mail",
  "notify.method.mail.text": "z.B. mailto:me@example.com",
  "notify.message.default": "... to send the server's default message",
  "notify.message.default.text": "A default implementation-specific message is used. It contains at least the value of the \"From\" header field and the value of the \"Subject\".",
  "notify.message.custom": "... to send a custom message",
  "notify.message.custom.text": "The message data to be included in the notification. Implementations may shorten the message for technical or aesthetic reasons.",
  "notify.from": "Override the default sender",
  "notify.from.text": "The server's default is normally the current user. You can override this, but in oder minimize/prevent forgery of the author value, the server implementations impose restrictions on what values can be specified.",
  "notify.importance": "Override the default importance",
  "notify.importance.text": "Only few protocols support an importance or priority at all. Refer to the method's documentation for more details on how the importance is mapped.",
  "notify.importance.high": "Hoch",
  "notify.importance.normal": "Normal",
  "notify.importance.low": "Niedrig",
  "notify.summary": "Send notification",
  "notify.options": "Set additional options",
  "notify.options.text": "Additional options passed to the mechanism as key and value pairs. Refer to the specific mechanisms for more details.",
  "notify.help": "Specifies that a notification should be sent to a user. The format of the notification is implementation-defined and is affected by the notification method used.\n\n The notification method is identified by a URI. For example, the notification method can be a tel URI [TEL-URI] with a phone number to send SMS messages to, or an XMPP [XMPP] URI containing an XMPP identifiers [XMPP-URI]. The supported notification methods are site-specific, but support for the [MailTo] method is guaranteed.\n\nSieve scripts should check the supported methods using the valid_notify_method test to be sure that they only use supported ones.",
  "notify.help.alert": "An implementation may enforce semantic restrictions on URIs. For example, to restrict phone numbers in a tel URI to a particular geographical region. This will cause a parser error.",
  "notifymethodcapability.summary": "Check Notify Method Capability",
  "validnotifymethod.tab.home": "Valid notify method",
  "validnotifymethod.tab.help": "Hilfe",
  "validnotifymethod.notifyuris": "All notify methods are supported...",
  "validnotifymethod.help": "",
  "validnotifymethod.summary": "Notify methods are supported",
  "redirect.tab.home": "Redirect",
  "redirect.tab.help": "Hilfe",
  "redirect.address.label": "E-Mail weiterleiten an:",
  "redirect.address.placeholder": "Hier die E-Mail Adresse eingeben",
  "redirect.address.invalid": "Ungültige Weiterleitungsaddresse",
  "redirect.help": "Redirect forwards the message to the given address. It makes no changes to the message body or existing headers, but it may add new headers.\n\n The envelope sender address on the outgoing message is chosen by the sieve implementation.\n\nImplementations may ignore a redirect action silently due to policy reasons.",
  "redirect.summary": "Redirect message to",
  "stop.summary": "End Script (Stop processing)",
  "discard.summary": "Discard message silently",
  "keep.summary": "Keep a copy in the main inbox",
  "size.tab.home": "Size",
  "size.tab.help": "Hilfe",
  "size.description": "Check if message size is ... ",
  "size.larger": "larger",
  "size.smaller": "smaller",
  "size.compare": "... than ...",
  "size.help": "Compares the message size.\n\nTest the message size is greater or smaller than the given size. The size is measured in bytes, character encoding are ignored.\n\n",
  "size.help.warning": "Es gibt nur ein größer oder kleiner, kein gleich. Eine Nachricht mit genau 4000 Bytes ist weder größer noch kleiner als 4000 Bytes.",
  "size.summary.message": "message is",
  "size.summary.larger": "größer",
  "size.summary.smaller": "kleiner",
  "size.summary.than": "als",
  "envelope.tab.home": "Envelope",
  "envelope.tab.advanced": "Erweitert",
  "envelope.tab.help": "Hilfe",
  "envelope.envelopes": "Any of the following envelope fields ...",
  "envelope.keywords": "... eines der folgenden Schlüsselwörter",
  "envelope.help": "Compares fields against the envelope\n\nThe envelop is equivalent to the mail delivery protocol. So it does not test against a real header. Instead uses trace information from the mail delivery protocol for specific values.\n\nA \"to\" tests the SMTP sender field \"RCPT TO\" a \"from\" the recipient \"MAIL FROM\".\n\nIt is the most reliant way to test from which address a message was send to or received.\n\nCompares headers against constant strings.\n\nYou typically use this test with headers containing subject line or a spam score.\n\nDo not use this test, if the header should be matched against a mail addresses. The result will be unreliable, as this test is not aware of display names. Use the address test instead.",
  "envelope.summary": "envelope",
  "address.tab.home": "Address",
  "address.tab.advanced": "Erweitert",
  "address.tab.help": "Hilfe",
  "address.headers": "Eine der folgenden Kopfzeilen...",
  "address.keywords": "... eines der folgenden Schlüsselwörter",
  "address.help": "Vergleicht Kopfzeilen eine E-Mail mit E-Mailadressen. Bei E-Mail Nachrichten besteht die E-Mailadresse typischerweise aus einem Anzeigename und der Adresse.\n\nIm Gegensatz zum 'header' Test, ignoriert ein 'address' Test den Anzeigenamen und wertet nur die Adresse aus. Die Kopfzeile '\"Roadrunner\" <roadrunner@acme.example.com> ' wird somit auf 'roadrunner@acme. xample.com' reduziert.\n\nDementsprechend sollte der Test für die Kopfzeile \"to\", \"from\", \"cc\" usw. verwendet werden.",
  "address.summary": "address",
  "allofanyof.tab.home": "AllOf/AnyOf",
  "allofanyof.tab.help": "Hilfe",
  "allofanyof.label": "Test ist erfüllt wenn...",
  "allofanyof.allof": "... alle Bedingungen erfüllt sind.",
  "allofanyof.anyof": "... mindestens eine Bedingungen erfüllt ist.",
  "allofanyof.help": "",
  "boolean.tab.home": "Boolean",
  "boolean.tab.help": "Hilfe",
  "boolean.label": "Make this test always",
  "boolean.true": "succeed (true)",
  "boolean.false": "fail (false)",
  "boolean.help": "Der Boolesche Test ist von begrenztem praktischem Nutzen. Die Bedingung ist immer erfüllt wenn er auf wahr (true) bzw. nie erfüllt wenn er auf falsch (false) gesetzt ist.",
  "boolean.summary.true": "is true",
  "boolean.summary.false": "is false",
  "condition.if": "if",
  "condition.else": "else",
  "condition.elseif": "elseif",
  "operator.allof.summary": "jede der folgenden Bedingungen erfüllt ist:",
  "operator.anyof.summary": "ein der folgenden Bedingungen erfüllt ist",
  "duplicate.tab.home": "Duplicate",
  "duplicate.tab.advanced": "Erweitert",
  "duplicate.tab.help": "Hilfe",
  "duplicate.summary": "is a duplicate",
  "duplicate.unique.label": "Die eindeutige Nachrichten Id ist...",
  "duplicate.tracking.title": "Tracking Handles",
  "duplicate.tracking.text": "Duplicate tracking considers only messages which are tagged with the same handle. The rational is to have multiple tracking policies. In case no handle it provided the server will use a default one. A custom handle can be any unique strings.",
  "duplicate.tracking.default": "Use default handle",
  "duplicate.tracking.custom": "Benutzerspezifisches Handle",
  "duplicate.tracking.custom.invalid": "Invalid custom handle",
  "duplicate.expiration.title": "Ablaufdatum",
  "duplicate.expiration.text": "The server uses a duplicate message list to track duplicates. To keep this list small and fast, the list entries expire. After a list entry is expired it is no more considered as a Duplicate",
  "duplicate.expiration.default": "Use server's default policy (usually 7 days)",
  "duplicate.expiration.custom.pre": "Ablauf nach",
  "duplicate.expiration.custom.post": "Sekunden",
  "duplicate.expiration.custom.invalid": "Ungültiges Ablaufdatum",
  "duplicate.time.text": "Expiration time uses either the point in time when the entry in the duplicate message list was created or the point in time when the duplicate message entry was last accessed.",
  "duplicate.time.created": "The moment the entry was created",
  "duplicate.time.accessed": "The timestamp of the most recent access",
  "duplicate.help": "The main application for this test is handling duplicate deliveries commonly caused by mailing list subscriptions or redirected mail addresses.\n\n The detection is normally performed by matching the message ID to an internal list of message IDs from previously delivered messages.\n\n For more complex applications, the \"duplicate\" test can also use the content of a specific header field or other parts of the message.\n\nDuplicate deliveries are a common side effect of being subscribed to a mailing list. For example, if a member of the list decides to reply to both the user and the mailing list itself, the user will often get one copy of the message directly and another through the mailing list.",
  "return.summary": "End current script and return to the parent script",
  "global.tab.home": "Global",
  "global.tab.help": "Hilfe",
  "global.title": "Export variables into the global namespace:",
  "global.help": "",
  "global.summary": "Define global variable(s):",
  "include.tab.home": "Include",
  "include.tab.advanced": "Erweitert",
  "include.tab.help": "Hilfe",
  "include.name": "Folgendes Script einbetten:",
  "include.name.placeholder": "Skriptname",
  "include.name.invalid": "Der Skriptname ist ungültig.",
  "include.once.label": "Maximal einmal einbetten",
  "include.once.text": "Mehrfach eingebundene Includeaufrufe zum selben Skript werden stillschweigend verworfen.",
  "include.optional.label": "Skript ist optional",
  "include.optional.text": "Ein 'include' wirft einen Fehler, wenn das Skript nicht gefunden wird.\nWenn das Skript jedoch als 'optional' markiert ist, wird es stillschweigend im Fehlerfall ignoriert.",
  "include.storage": "Ablageort",
  "include.personal.label": "Personal (default)",
  "include.personal.text": "Personal scripts are located in your personal and private Sieve repository.",
  "include.global.label": "Global",
  "include.global.text": "Global scripts are stored in a site-wide Sieve repository.\nIt is accessible to all users any typically provided and maintained by your administrator.",
  "include.help": "",
  "include.summary1": "Include",
  "include.summary.personal": "global",
  "include.summary.global": "personal",
  "include.summary2": "script",
  "date.tab.home": "Date",
  "date.tab.advanced": "Erweitert",
  "date.tab.help": "Hilfe",
  "date.header": "Hat eine Kopfzeile...",
  "date.datepart": "... bei der ...",
  "date.keywords": "... eines der folgenden Schlüsselwörter",
  "date.timezone": "Zeitzone",
  "date.comparator": "Comparator",
  "date.help": "The date/time information is extracted from the header, shifted to the specified time zone, and the value of the given date-part is determined.\n\nThe test returns true if the resulting string matches any of the strings specified in the key-list.\n\nThe date test returns false if the specified header field does not exist, the field exists but does not contain a syntactically valid date-time specification, the date-time isn't valid according to the rules of the calendar system (e.g., January 32nd, February 29 in a non-leap year), or the resulting string fails to match any key-list value\n\n Unlike the header and address tests, the date test can only be applied to a single header field at a time. If multiple header fields with the same name are present, only the first field that is found is used.",
  "date.summary.inheader": "in header",
  "date.summary.anyof": "any of",
  "currentdate.tab.home": "Current Date",
  "currentdate.tab.advanced": "Erweitert",
  "currentdate.tab.help": "Hilfe",
  "currentdate.datepart": "Das derzeitige... ",
  "currentdate.keyword": "... eines der folgenden Schlüsselwörter",
  "currentdate.timezone": "Zeitzone",
  "currentdate.comparator": "Comparator",
  "currentdate.help": "The currentdate test is similar to the date test, except that it operates on the current date/time rather than a value extracted from the message header.\n\nThe test returns true if the current date matches any of the strings specified in the key-list. It returns false if the resulting string fails to match any key-list value.",
  "currentdate.summary.current": "The current",
  "currentdate.summary.anyof": "any of",
  "datepart.year": "Jahr",
  "datepart.year.text": "\"0000\" ... \"9999\"",
  "datepart.month": "Monat",
  "datepart.month.text": "\"01\" ... \"12\"",
  "datepart.day": "Tag",
  "datepart.day.text": "\"01\" ... \"31\"",
  "datepart.date": "Datum",
  "datepart.date.text": "\"yyyy-mm-dd\"",
  "datepart.hour": "Stunde",
  "datepart.hour.text": "\"00\" ... \"23\"",
  "datepart.minute": "Minute",
  "datepart.minute.text": "\"00\" ... \"59\"",
  "datepart.second": "Sekunde",
  "datepart.second.text": "\"00\" ... \"60\"",
  "datepart.time": "Zeit",
  "datepart.time.text": "\"hh:mm:ss\"",
  "datepart.iso8601": "iso8601",
  "datepart.iso8601.text": "Restricted ISO 8601 Format (RFC3339)",
  "datepart.std11": "std11",
  "datepart.std11.text": "Internet Message Format (RFC2822)",
  "datepart.zone": "Zeitzone",
  "datepart.zone.text": "Zeitzone (\"+hhmm\" oder \"-hhmm\")",
  "datepart.weekday": "Wochentag",
  "datepart.weekday.text": "\"0\" (Sonntag) ... \"6\" (Samstag)",
  "datepart.julian": "julianischer Kalendertag",
  "datepart.julian.text": "Tage seit 1858-11-17 0:00 UTC",
  "zone.original": "Original zone",
  "zone.original.text": "Use the time zone offset from the date-time value.",
  "zone.custom": "Adjust Timezone",
  "zone.custom.text": "Die Zeitzone des data-time Wertes ändern.\n\nDas Format für die Zeitzone ist ±[hh][mm], der Wert muss im Bereich von -1200 bis +1400 liegen. Die meisten Zeitzonen sind volle Stunden, es gibt nur wenige Zwischenzonen die um 30 bzw. 45 Minuten versetzt sind, wie z.B. −0330 oder +0545",
  "convert.tab.home": "Convert",
  "convert.tab.help": "Hilfe",
  "convert.from": "Convert the media type",
  "convert.to": "... into ...",
  "convert.transcode": "... and apply the following transcodings",
  "convert.transcode.text": "Transcodings are defined in RFC5259 and used to change properties during conversion.  Examples are rescale an images or change the encoding of a text.",
  "convert.help": "Converts the whole message or their part into the a new media type. It is typically used to convert text documents and images as described in RFC5259.\n\nTheoretically it would be possible to convert everything into anything (e.g. an audio file into text). But in reality your server will support only a very limited subset of conversions. Keep in mind conversion may require lots of resources and processing time e.g. when rescaling images or creating pdfs.\n\nIn case the conversion fails the message remains unchanged. If this method is used inside a test. The test will performing the conversion and evaluate if the conversion succeeded or failed.",
  "convert.summary.from": "Convert",
  "convert.summary.to": "to",
  "body.tab.home": "Body",
  "body.tab.advanced": "Erweitert",
  "body.tab.help": "Hilfe",
  "body.matchtypes": "The email's message body...",
  "body.keylist": "... any of the keyword(s):",
  "body.comparator": "Comparator",
  "body.transform": "Match against...",
  "body.help": "The body test matches content in the body of an email message, that is, anything following the first empty line after the header. (The empty line itself, if present, is not considered to be part of the body.",
  "body.summary": "message body",
  "addflag.tab.home": "Add Flag",
  "addflag.tab.help": "Hilfe",
  "addflag.flags.title": "Die folgenden IMAP Flags setzen...",
  "addflag.flags.text": "It doesn't replace any previously set flags. This means that multiple occurrences of addflag are treated additively.",
  "addflag.help": "Add flags to a message. It doesn't replace any previously set flags. This means that multiple occurrences of addflag are treated additively.\n\nMessage labels are called flags in the IMAP specification and are divided into two types: system flags and user-defined flags.\n\nSystem flags are defined in the IMAP Specification. They start with a leading backslash (\\). The current the following six system flags \\Seen, \\Answered, \\Flagged, \\Deleted, \\Draft, \\Recent are defined.\n\nUser-defined flags are also known as IMAP keywords and, as the name implies, are defined by IMAP users. There is a de facto standard that keywords which are in common use have names that begin with a dollar sign ($).\n\nExamples of common keywords are: $Label1, $Label2, $Label3, $Label4, $Label5. These keywords are typically hardwired to Important, Work, Personal, To Do and Later.\n\nIf you define your own personal keyword, its name should not begin with dollar sign ($) or backslash (\\) because otherwise it might collide with a flag that is used by current or future IMAP clients and servers",
  "addflag.summary": "Add IMAP flag(s)",
  "spamtest.tab.home": "Spamtest",
  "spamtest.tab.advanced": "Erweitert",
  "spamtest.tab.help": "Hilfe",
  "spamtest.spamscore": "The spam score...",
  "spamtest.help": "",
  "spamtest.absolute.label": "... absolute value ...",
  "spamtest.absolute.text": "By default sieve uses a spam score ranging from zero to ten describing the likelihood to be spam. Where zero means untested, one clear of spam and ten definitive spam.",
  "spamtest.absolute.nottested": "Nachricht wurde nicht auf Spam getestet",
  "spamtest.absolute.nospam": "Nachricht ist frei von Spam",
  "spamtest.absolute.likelyspan": "Spam-Wahrscheinlichkeit der Nachricht",
  "spamtest.absolute.spam": "Nachricht ist definitiv Spam",
  "spamtest.percent.label": "... percentual value ...",
  "spamtest.percent.text": "The spam score can also be a likelihood ranging from zero to 100. Where zero means no spam or untested and 100 definitive spam",
  "spamtest.percent.nospam": "Nachricht wurde nicht auf Spam getestet oder ist frei von Spam",
  "spamtest.percent.likelyspan": "Spam-Wahrscheinlichkeit in Prozent",
  "spamtest.percent.spam": "Nachricht ist definitiv Spam",
  "spamtest.summary": "Spam score",
  "hasflag.tab.home": "Has Flag",
  "hasflag.tab.advanced": "Erweitert",
  "hasflag.tab.help": "Hilfe",
  "hasflag.flags.title": "Es existiert ein IMAP Flag ...",
  "hasflag.flags.keyword": "... eines der folgenden Schlüsselwörter",
  "hasflag.help": "Message labels are called flags in the IMAP specification and are divided into two types: system flags and user-defined flags.\n\n  System flags are defined in the IMAP Specification. They start with a leading backslash (\\). The current the following six system flags \\Seen, \\Answered, \\Flagged, \\Deleted, \\Draft, \\Recent are defined.\n\nUser-defined flags are also known as IMAP keywords and, as the name implies, are defined by IMAP users. There is a de facto standard that keywords which are in common use have names that begin with a dollar sign ($).\n\n Examples of common keywords are: $Label1, $Label2, $Label3, Label4, $Label5. These keywords are typically hardwired to Important, Work, Personal, To Do and Later.\n\n If you define your own personal keyword, its name should not begin with dollar sign ($) or backslash (\\) because otherwise it might collide with a flag that is used by current or future IMAP clients and servers.",
  "hasflag.summary": "An IMAP flags(s)",
  "removeflag.tab.home": "Remove Flag",
  "removeflag.tab.help": "Hilfe",
  "removeflag.flags.title": "Die folgenden IMAP Flags entfernen...",
  "removeflag.flags.text": "Removeflag clears flags previously set by setflag or addflag",
  "removeflag.help": "Removeflag clears flags previously set by \"setflag\" or \"addflag\". Calling removeflag with a flag that wasn't set before is not an error and is ignored. \n\nAdd flags to a message. It doesn't replace any previously set flags. This means that multiple occurrences of addflag are treated additively.\n\nMessage labels are called flags in the IMAP specification and are divided into two types: system flags and user-defined flags.\n\nSystem flags are defined in the IMAP Specification. They start with a leading backslash (\\). The current the following six system flags \\Seen , \\Answered, \\Flagged, \\Deleted, \\Draft, \\Recent are defined.\n\nUser-defined flags are also known as IMAP keywords and, as the name implies, are defined by IMAP users. There is a de facto standard that keywords which are in common use have names that begin with a dollar sign ($).\n\nExamples of common keywords are: $Label1, $Label2, $Label3, $Label4, $Label5. These keywords are typically hardwired to Important, Work, Personal, To Do and Later.\n\nIf you define your own personal keyword, its name should not begin with dollar sign ($) or backslash (\\) because otherwise it might collide with a flag that is used by current or future IMAP clients and servers",
  "removeflag.summary": "Remove IMAP flag(s)",
  "setflags.tab.home": "Set Flag",
  "setflags.tab.help": "Hilfe",
  "setflags.flags.title": "Set the following IMAP Flags ...",
  "setflags.flags.text": "It replaces any previously set flags.",
  "setflag.help": "Setflag is used for setting system flags, it replaces any previously set flags.\n\nMessage labels are called flags in the IMAP specification and are divided into two types: system flags and user-defined flags.\n\nSystem flags are defined in the IMAP Specification. They start with a leading backslash (\\). The current the following six system flags \\Seen , \\Answered, \\Flagged, \\Deleted, \\Draft, \\Recent are defined.\n\nUser-defined flags are also known as IMAP keywords and, as the name implies, are defined by IMAP users. There is a de facto standard that keywords which are in common use have names that begin with a dollar sign ($).\n\n Examples of common keywords are: $Label1, $Label2, $Label3, $Label4, $Label5. These keywords are typically hardwired to Important, Work, Personal, To Do and Later.\n\nIf you define your own personal keyword, its name should not begin with dollar sign ($) or backslash (\\) because otherwise it might collide with a flag that is used by current or future IMAP clients and servers",
  "setflag.summary": "Set IMAP flag(s)",
  "flags.label": "Add imap flag",
  "flags.text": "Adds flags to a message. It doesn't replace any previously set flags.",
  "copy.label": "Keep a copy",
  "copy.text": "By default the action cancels the implicit keep statement. So that it won't be stored in the inbox after processing. When activating a copy of the original message is kept in the inbox.",
  "create.label": "Ordner erstellen, wenn nicht vorhanden",
  "unique.default.title": "... extracted from the header named message-id.",
  "unique.default.text": "Die Message-Id ist normalerwise global einzigartig, es gibt jedoch keine Garantien.",
  "unique.header.title": "... aus der Kopfzeile mit Namen:",
  "unique.header.text": "Oft verwenden Mailinglisten- oder Ticketsysteme spezielle Kopfzeilen, um Duplikate zu erkennen.",
  "unique.id.title": "... is provided:",
  "unique.id.text": "Using a static string does not sound too usefull. But in combination with sieve variables, the string will get virtually dynamic. And you are able to create almost any unique id pattern to match against.",
  "bodyTransform.contentType": "... the MIME parts that have the specified content types:",
  "bodyTransform.text": "... the decoded message body. (Default)",
  "bodyTransform.raw": "... the entire undecoded message body",
  "matchtype.is.title": "... ist ...",
  "matchtype.is.text": "Nur \"Frobnitzm\" ist \"Frobnitzm\"",
  "matchtype.contains.title": "... enthält ...",
  "matchtype.contains.text": "\"frobnitzm\" enthält \"frob\" und \"nit\", aber nicht \"fbm\"",
  "matchtype.matches.title": "... matches ...",
  "matchtype.matches.text": "\"*\" matches zero or more characters, and \"?\" matches a single character\n\"frobnitzm\" matches \"frob*zm\" or \"frobnit?m\" but not frob?m",
  "matchtype.value.title": "... is",
  "matchtype.value.title2": "...",
  "matchtype.value.greater": "größer als",
  "matchtype.value.greaterEqual": "größer oder gleich",
  "matchtype.value.less": "kleiner als",
  "matchtype.value.lessEqual": "kleiner oder gleich",
  "matchtype.value.equal": "gleich",
  "matchtype.value.notEqual": "ungleich",
  "matchtype.value.text": "Compares the relation between strings. The test is considered true if any pair is true",
  "matchtype.regex.title": "... regex matches ...",
  "matchtype.regex.text": "Matches and compares using on a regular expression as defined in IEEE.1003-2.1992",
  "matchtype.count.title": "... hat",
  "matchtype.count.title2": "Elemente als...",
  "matchtype.count.greater": "mehr",
  "matchtype.count.greaterEqual": "mehr oder gleichviel",
  "matchtype.count.less": "weniger",
  "matchtype.count.lessEqual": "weniger oder gleichviel",
  "matchtype.count.equal": "gleichviele",
  "matchtype.count.notEqual": "not equal to",
  "matchtype.count.text": "Zählt die Anzahl der Elemente und vergleicht sie gegen die Werte.",
  "modifier.length.title": "Zeichen zählen",
  "modifier.length.text": "Variablen werden erst erweitert, bevor die Zeichen gezählt werden.",
  "modifier.quotewildcard.title": "Escape Wildcards",
  "modifier.quotewildcard.text": "Ensures that the expanded text will only match a literal occurrence if used as a parameter to :matches. Every character with special meaning (\"*\", \"?\", and \"\\\") is prefixed with \"\\\" in the expansion.",
  "modifier.encodeurl.title": "Url Encodieren",
  "modifier.encodeurl.text": "Kodiert die Variable im Url Format. Für jedes Oktett das nicht geschützt ist, wird eine Prozentkodierung durchgeführt geschützte Zeichen bleiben unverändert.",
  "addresspart.all.title": "... eine E-Mail-Adresse mit ...",
  "addresspart.all.text": "Eine E-Mail-Adresse besteht aus einer Domäne und einem durch das Zeichen \"@\" getrennten lokalen Teil. Bei dem lokalen Teil wird Groß- und Kleinschreibung unterschieden, bei der Domäne nicht.",
  "addresspart.domain.title": "... eine Domäne mit...",
  "addresspart.domain.text": "Alles nach dem @ Zeichen. Bei der Domäne wird nicht zwischen Groß- und Kleinschreibung unterschieden.\nz.B. : \"me@example.com\" wird zu \"example.com\"",
  "addresspart.local.title": "... einen lokalen Teil mit...",
  "addresspart.local.text": "Alles vor dem @ Zeichen. Beim lokalen Teil wird zwischen Groß-/Kleinschreibung unterschieden.\nz.B.: \"me@example.com\" wird zu \"me\"",
  "addresspart.user.title": "... ein Benutzerteil mit ...",
  "addresspart.user.text": "Alles vor dem + Zeichen oder zwischen der -- Sequenz und dem @ Zeichen.\nGroß- und Kleinschreibung wird unterschieden.\nz.B.: \"user+detail@example.com\" oder \"detail--user@example.com\" wird zu \"user\"",
  "addresspart.detail.title": "... einen Detailanteil mit...",
  "addresspart.detail.text": "Alles zwischen dem + Zeichen und dem @ Zeichen oder vor der -- Sequenz.\nGroß- und Kleinschreibung wird unterschieden.\nz.B.: \"user+detail@example.com\" oder \"detail--user@example.com\" wird zu \"detail\"",
  "comparator.asciicasemap.title": "Case insensitive (default)",
  "comparator.asciicasemap.text": "Treats uppercase and lowercase ASCII characters as the same.\nAll non ASCII characters are compared byte by byte.",
  "comparator.asciinumeric.title": "Numeric",
  "comparator.asciinumeric.text": "Converts the string to an integer and does a numeric compare.",
  "comparator.octet.title": "Case sensitive",
  "comparator.octet.text": "Compares the string byte by byte.",
  "interval.days.label.pre": "Höchstens alle",
  "interval.days.label.post": "Tage",
  "interval.default.label": "Use Server's default policy",
  "interval.seconds.label.pre": "Höchstens alle",
  "interval.seconds.label.post": "Sekunden",
  "virustest.tab.home": "Virustest",
  "virustest.tab.advanced": "Erweitert",
  "virustest.tab.help": "Hilfe",
  "virustest.title": "Das Ergebnis des Virenscanner...",
  "virustest.nottested": "Nachricht wurde nicht auf Viren getestet",
  "virustest.notinfected": "Message was tested and contains no known viruses",
  "virustest.sanitized": "Message contained a known virus that was replaced with harmless content",
  "virustest.cured": "Message contained a known virus that was \"cured\" such that it is now harmless",
  "virustest.likelyinfected": "Message possibly contains a known virus",
  "virustest.infected": "Message was tested and definitely contains a known virus",
  "virustest.help": "The \"virustest\" test evaluates to true if the normalized result string matches the value.\n\nThe normalized result string starts with a numeric value in the range \"0\" (zero) through \"5\", with meanings summarized below:",
  "virustest.summary": "Virus check",
  "vacation.tab.home": "Vacation",
  "vacation.tab.envelope": "Envelope",
  "vacation.tab.advanced": "Erweitert",
  "vacation.tab.help": "Hilfe",
  "vacation.envelope.subject": "Betreff:",
  "vacation.envelope.subject.default": "Standard Betreff des Servers",
  "vacation.envelope.from": "Von:",
  "vacation.envelope.from.default": "Adresse des Sieve Kontos",
  "vacation.envelope.addresses": "Adressen:",
  "vacation.envelope.text": "Enter your vacation message",
  "vacation.subject": "Betreff",
  "vacation.subject.text": "The subject is used for any vacation response",
  "vacation.subject.default": "Server's default Subject",
  "vacation.subject.custom": "Custom Subject",
  "vacation.from": "From address",
  "vacation.from.text": "Used to specify an alternate From address.",
  "vacation.from.default": "Address of the sieve script owner",
  "vacation.from.custom": "Custom From Address",
  "vacation.addresses": "Additional recipients addresses",
  "vacation.addresses.text": "By default a response message is only send, if it was addressed to the recipient user or sieve script owner.\nYou can supply additional mail addresses. For Example if mails are forwarded or you have multiple aliases for a single mail address",
  "vacation.contenttype": "Message Content Type",
  "vacation.contenttype.text": "Instead of plaintext, the message can be a specified as a MIME Message",
  "vacation.contenttype.default": "Is plaintext Message (Default)",
  "vacation.contenttype.mime": "Is MIME Message",
  "vacation.tracking": "Response Tracking",
  "vacation.tracking.text": "Eine Abwesenheitsnachricht wird höchstens alle paar Tage an denselben Absender gesendet",
  "vacation.response": "Response Handles",
  "vacation.response.text": "The response tracking considers all vacation statements that use the same handle as the same response\nThe default handle considers subject, from, mime as well as the message. A custom handle can be any unique strings",
  "vacation.response.default": "Use default handle",
  "vacation.response.custom": "Custom Handle",
  "vacation.help": "The \"vacation\" action implements a vacation autoresponder similar to the vacation command available under many versions of Unix. Its purpose is to provide correspondents with notification that the user is away for an extended period of time and that they should not expect quick responses.\n\n\"Vacation\" is used to respond to a message with another message. Vacation's messages are always addressed to the Return-Path address (that is, the envelope from address) of the message being responded to.",
  "vacation.summary": "Senden eine Abwesenheitsnachricht:",
  "environment.tab.home": "Environment",
  "environment.tab.advanced": "Erweitert",
  "environment.tab.help": "Hilfe",
  "environment.name": "Die Umgebungsvariable...",
  "environment.name.domain": "Primäre DNS der Maschine, die das Sieve-Skript ausführt.",
  "environment.name.host": "Vollqualifizierter Domänen der Maschine die das Sieve-Skript ausführt.",
  "environment.name.location": "Provides additional information about the type of service that is evaluating the script.\nWell known services are \"MTA\" (Message Transfer Agent), \"MDA\" (Mail Delivery Agent),\n\"MUA\" (Mail User Agent) and \"MS\" (Message Store).",
  "environment.name.name": "Name des Sieve Interpreters",
  "environment.name.phase": "Current delivery phase.\nCan be before (\"pre\"), during (\"during\"), and after final delivery (\"post\")",
  "environment.name.remotehost": "Host name of remote client as a Fully Qualified Domain Name (FQDN)\nAn empty string means, sieve failed to obtain this information",
  "environment.name.remoteip": "IP address of remote client in standard notation",
  "environment.name.version": "Die Version des Sieve Interpreter",
  "environment.keys": "... einer der folgenden Werte...",
  "environment.help": "The environment test retrieves the item of environment information specified by the name string and matches it to the values specified in the key-list argument. The test succeeds if a match occurs.\n\n The current message is not a direct source of information for the environment test; the item of information specified by the name string is extracted from the script's operating environment and the key-list argument comes from the script.",
  "environment.summary": "Environment info named",
  "pipe.tab.home": "Pipe",
  "pipe.tab.help": "Hilfe",
  "pipe.program.label": "Pipe the message to the program",
  "pipe.program.placeholder": "The program to be executed",
  "pipe.program.invalid": "The program name is invalid.",
  "pipe.arguments.label": "Pass arguments",
  "pipe.arguments.text": "Command line arguments to be passed to the external program.",
  "pipe.try.label": "Fail silently",
  "pipe.try.text": "Do not trigger an error in case executing the program failed.",
  "pipe.copy.label": "Keep a copy",
  "pipe.copy.text": "Do not cancel the implicit keep.",
  "pipe.help": "Pipe executes an external program on the server and pipes the messag into this program.\n\nIn case the program terminated without an error, the implicit keep will be canceled.",
  "pipe.summary": "Pipe message to",
  "filter.tab.home": "Filter",
  "filter.tab.help": "Hilfe",
  "filter.program.label": "Run message through filter program",
  "filter.program.placeholder": "The program to be executed",
  "filter.program.invalid": "The program name is invalid.",
  "filter.arguments.label": "Pass arguments",
  "filter.arguments.text": "Command line arguments to be passed to the external program.",
  "filter.help": "The filter action executes an external program. The current message is forwarded to the program to process it. The ouput replaces the old message.\n\nThe filter action does not affect the implicit keep.\n\nIn case the program terminates with an error, the message it left unchanged.",
  "filter.summary": "Run message through filter program",
  "filter.summary.test.pre": "Message ran through filter program ",
  "filter.summary.test.post": " without errors",
  "execute.tab.home": "Execute",
  "execute.tab.help": "Hilfe",
  "execute.program.label": "Execute external program",
  "execute.program.placeholder": "The program to be executed",
  "execute.program.invalid": "The program name is invalid.",
  "execute.arguments.label": "Pass arguments",
  "execute.arguments.text": "Command line arguments to be passed to the external program.",
  "execute.input.label": "Pass data to the program",
  "execute.input.input.title": "Use custom string",
  "execute.input.placeholder": "Custom data to be passed.",
  "execute.input.input.text": "The string may contain variable subsitutions which will be resolved before passing the data.",
  "execute.input.pipe.title": "Use current message",
  "execute.output.label": "Capture output to variable",
  "execute.output.text": "The programs output will be stored into a sieve variable when the program exected finished without an error.",
  "execute.output.placeholder": "Variable name which stores the output.",
  "execute.help": "Executes an external program.\n\nThe optional input can be forwarded to the program as well as output can be returned from the script.",
  "execute.summary": "Run program ",
  "execute.summary.test.pre": "Programm",
  "execute.summary.test.post": "ran without errors",
  "not.summary": "does not match"
}